/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Don't edit this file!  It is auto-generated by frameworks/rs/api/gen_runtime.

package android.renderscript.cts;

import android.renderscript.Allocation;
import android.renderscript.RSRuntimeException;
import android.renderscript.Element;

public class TestClamp extends RSBaseCompute {

    private ScriptC_TestClamp script;
    private ScriptC_TestClampRelaxed scriptRelaxed;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        script = new ScriptC_TestClamp(mRS);
        scriptRelaxed = new ScriptC_TestClampRelaxed(mRS);
    }

    public class ArgumentsFloatFloatFloatFloat {
        public float inValue;
        public float inMinValue;
        public float inMaxValue;
        public float out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkClampFloatFloatFloatFloat() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0xa72e74a305a95f28L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0xa72e74a305a95f28L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0xa72e74a305a95f28L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampFloatFloatFloatFloat(inValue, out);
            verifyResultsClampFloatFloatFloatFloat(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloatFloatFloatFloat: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampFloatFloatFloatFloat(inValue, out);
            verifyResultsClampFloatFloatFloatFloat(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloatFloatFloatFloat: " + e.toString());
        }
    }

    private void verifyResultsClampFloatFloatFloatFloat(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        float[] arrayInValue = new float[INPUTSIZE * 1];
        inValue.copyTo(arrayInValue);
        float[] arrayInMinValue = new float[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        float[] arrayInMaxValue = new float[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        float[] arrayOut = new float[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloatFloat args = new ArgumentsFloatFloatFloatFloat();
                args.inValue = arrayInValue[i];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                neededUlf = (int) (Math.abs(args.out - arrayOut[i * 1 + j]) / Math.ulp(args.out) + 0.5);
                if (neededUlf > ulf) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x %.16f", Float.floatToRawIntBits(args.inValue), args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x %.16f", Float.floatToRawIntBits(args.inMinValue), args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x %.16f", Float.floatToRawIntBits(args.inMaxValue), args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x %.16f", Float.floatToRawIntBits(args.out), args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x %.16f", Float.floatToRawIntBits(arrayOut[i * 1 + j]), arrayOut[i * 1 + j]));
                    neededUlf = (int) (Math.abs(args.out - arrayOut[i * 1 + j]) / Math.ulp(args.out) + 0.5);
                    if (neededUlf > ulf) {
                        message.append(String.format(" FAILED, ulf needed %d, specified %d", neededUlf, ulf));
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampFloatFloatFloatFloat" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampFloat2Float2Float2Float2() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 2, 0x662f14ca3d7fd390L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 2, 0x662f14ca3d7fd390L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 2, 0x662f14ca3d7fd390L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampFloat2Float2Float2Float2(inValue, out);
            verifyResultsClampFloat2Float2Float2Float2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat2Float2Float2Float2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampFloat2Float2Float2Float2(inValue, out);
            verifyResultsClampFloat2Float2Float2Float2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat2Float2Float2Float2: " + e.toString());
        }
    }

    private void verifyResultsClampFloat2Float2Float2Float2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        float[] arrayInValue = new float[INPUTSIZE * 2];
        inValue.copyTo(arrayInValue);
        float[] arrayInMinValue = new float[INPUTSIZE * 2];
        inMinValue.copyTo(arrayInMinValue);
        float[] arrayInMaxValue = new float[INPUTSIZE * 2];
        inMaxValue.copyTo(arrayInMaxValue);
        float[] arrayOut = new float[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloatFloat args = new ArgumentsFloatFloatFloatFloat();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                neededUlf = (int) (Math.abs(args.out - arrayOut[i * 2 + j]) / Math.ulp(args.out) + 0.5);
                if (neededUlf > ulf) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x %.16f", Float.floatToRawIntBits(args.inValue), args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x %.16f", Float.floatToRawIntBits(args.inMinValue), args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x %.16f", Float.floatToRawIntBits(args.inMaxValue), args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x %.16f", Float.floatToRawIntBits(args.out), args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x %.16f", Float.floatToRawIntBits(arrayOut[i * 2 + j]), arrayOut[i * 2 + j]));
                    neededUlf = (int) (Math.abs(args.out - arrayOut[i * 2 + j]) / Math.ulp(args.out) + 0.5);
                    if (neededUlf > ulf) {
                        message.append(String.format(" FAILED, ulf needed %d, specified %d", neededUlf, ulf));
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampFloat2Float2Float2Float2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampFloat3Float3Float3Float3() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 3, 0x41bdbe03e90eeb4cL);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 3, 0x41bdbe03e90eeb4cL);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 3, 0x41bdbe03e90eeb4cL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampFloat3Float3Float3Float3(inValue, out);
            verifyResultsClampFloat3Float3Float3Float3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat3Float3Float3Float3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampFloat3Float3Float3Float3(inValue, out);
            verifyResultsClampFloat3Float3Float3Float3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat3Float3Float3Float3: " + e.toString());
        }
    }

    private void verifyResultsClampFloat3Float3Float3Float3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        float[] arrayInValue = new float[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        float[] arrayInMinValue = new float[INPUTSIZE * 4];
        inMinValue.copyTo(arrayInMinValue);
        float[] arrayInMaxValue = new float[INPUTSIZE * 4];
        inMaxValue.copyTo(arrayInMaxValue);
        float[] arrayOut = new float[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloatFloat args = new ArgumentsFloatFloatFloatFloat();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                neededUlf = (int) (Math.abs(args.out - arrayOut[i * 4 + j]) / Math.ulp(args.out) + 0.5);
                if (neededUlf > ulf) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x %.16f", Float.floatToRawIntBits(args.inValue), args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x %.16f", Float.floatToRawIntBits(args.inMinValue), args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x %.16f", Float.floatToRawIntBits(args.inMaxValue), args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x %.16f", Float.floatToRawIntBits(args.out), args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x %.16f", Float.floatToRawIntBits(arrayOut[i * 4 + j]), arrayOut[i * 4 + j]));
                    neededUlf = (int) (Math.abs(args.out - arrayOut[i * 4 + j]) / Math.ulp(args.out) + 0.5);
                    if (neededUlf > ulf) {
                        message.append(String.format(" FAILED, ulf needed %d, specified %d", neededUlf, ulf));
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampFloat3Float3Float3Float3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampFloat4Float4Float4Float4() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 4, 0x1d4c673d949e0308L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 4, 0x1d4c673d949e0308L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 4, 0x1d4c673d949e0308L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampFloat4Float4Float4Float4(inValue, out);
            verifyResultsClampFloat4Float4Float4Float4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat4Float4Float4Float4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampFloat4Float4Float4Float4(inValue, out);
            verifyResultsClampFloat4Float4Float4Float4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat4Float4Float4Float4: " + e.toString());
        }
    }

    private void verifyResultsClampFloat4Float4Float4Float4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        float[] arrayInValue = new float[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        float[] arrayInMinValue = new float[INPUTSIZE * 4];
        inMinValue.copyTo(arrayInMinValue);
        float[] arrayInMaxValue = new float[INPUTSIZE * 4];
        inMaxValue.copyTo(arrayInMaxValue);
        float[] arrayOut = new float[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloatFloat args = new ArgumentsFloatFloatFloatFloat();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                neededUlf = (int) (Math.abs(args.out - arrayOut[i * 4 + j]) / Math.ulp(args.out) + 0.5);
                if (neededUlf > ulf) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x %.16f", Float.floatToRawIntBits(args.inValue), args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x %.16f", Float.floatToRawIntBits(args.inMinValue), args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x %.16f", Float.floatToRawIntBits(args.inMaxValue), args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x %.16f", Float.floatToRawIntBits(args.out), args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x %.16f", Float.floatToRawIntBits(arrayOut[i * 4 + j]), arrayOut[i * 4 + j]));
                    neededUlf = (int) (Math.abs(args.out - arrayOut[i * 4 + j]) / Math.ulp(args.out) + 0.5);
                    if (neededUlf > ulf) {
                        message.append(String.format(" FAILED, ulf needed %d, specified %d", neededUlf, ulf));
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampFloat4Float4Float4Float4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampFloat2FloatFloatFloat2() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 2, 0xe76aa9804cd9616cL);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0xe76aa9804cd9616cL);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0xe76aa9804cd9616cL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampFloat2FloatFloatFloat2(inValue, out);
            verifyResultsClampFloat2FloatFloatFloat2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat2FloatFloatFloat2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampFloat2FloatFloatFloat2(inValue, out);
            verifyResultsClampFloat2FloatFloatFloat2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat2FloatFloatFloat2: " + e.toString());
        }
    }

    private void verifyResultsClampFloat2FloatFloatFloat2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        float[] arrayInValue = new float[INPUTSIZE * 2];
        inValue.copyTo(arrayInValue);
        float[] arrayInMinValue = new float[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        float[] arrayInMaxValue = new float[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        float[] arrayOut = new float[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloatFloat args = new ArgumentsFloatFloatFloatFloat();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                neededUlf = (int) (Math.abs(args.out - arrayOut[i * 2 + j]) / Math.ulp(args.out) + 0.5);
                if (neededUlf > ulf) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x %.16f", Float.floatToRawIntBits(args.inValue), args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x %.16f", Float.floatToRawIntBits(args.inMinValue), args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x %.16f", Float.floatToRawIntBits(args.inMaxValue), args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x %.16f", Float.floatToRawIntBits(args.out), args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x %.16f", Float.floatToRawIntBits(arrayOut[i * 2 + j]), arrayOut[i * 2 + j]));
                    neededUlf = (int) (Math.abs(args.out - arrayOut[i * 2 + j]) / Math.ulp(args.out) + 0.5);
                    if (neededUlf > ulf) {
                        message.append(String.format(" FAILED, ulf needed %d, specified %d", neededUlf, ulf));
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampFloat2FloatFloatFloat2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampFloat3FloatFloatFloat3() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 3, 0x687f6efb2625c522L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0x687f6efb2625c522L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0x687f6efb2625c522L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampFloat3FloatFloatFloat3(inValue, out);
            verifyResultsClampFloat3FloatFloatFloat3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat3FloatFloatFloat3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampFloat3FloatFloatFloat3(inValue, out);
            verifyResultsClampFloat3FloatFloatFloat3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat3FloatFloatFloat3: " + e.toString());
        }
    }

    private void verifyResultsClampFloat3FloatFloatFloat3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        float[] arrayInValue = new float[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        float[] arrayInMinValue = new float[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        float[] arrayInMaxValue = new float[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        float[] arrayOut = new float[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloatFloat args = new ArgumentsFloatFloatFloatFloat();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                neededUlf = (int) (Math.abs(args.out - arrayOut[i * 4 + j]) / Math.ulp(args.out) + 0.5);
                if (neededUlf > ulf) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x %.16f", Float.floatToRawIntBits(args.inValue), args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x %.16f", Float.floatToRawIntBits(args.inMinValue), args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x %.16f", Float.floatToRawIntBits(args.inMaxValue), args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x %.16f", Float.floatToRawIntBits(args.out), args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x %.16f", Float.floatToRawIntBits(arrayOut[i * 4 + j]), arrayOut[i * 4 + j]));
                    neededUlf = (int) (Math.abs(args.out - arrayOut[i * 4 + j]) / Math.ulp(args.out) + 0.5);
                    if (neededUlf > ulf) {
                        message.append(String.format(" FAILED, ulf needed %d, specified %d", neededUlf, ulf));
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampFloat3FloatFloatFloat3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampFloat4FloatFloatFloat4() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 4, 0xe9943475ff7228d8L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0xe9943475ff7228d8L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0xe9943475ff7228d8L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampFloat4FloatFloatFloat4(inValue, out);
            verifyResultsClampFloat4FloatFloatFloat4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat4FloatFloatFloat4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampFloat4FloatFloatFloat4(inValue, out);
            verifyResultsClampFloat4FloatFloatFloat4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat4FloatFloatFloat4: " + e.toString());
        }
    }

    private void verifyResultsClampFloat4FloatFloatFloat4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        float[] arrayInValue = new float[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        float[] arrayInMinValue = new float[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        float[] arrayInMaxValue = new float[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        float[] arrayOut = new float[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloatFloat args = new ArgumentsFloatFloatFloatFloat();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                neededUlf = (int) (Math.abs(args.out - arrayOut[i * 4 + j]) / Math.ulp(args.out) + 0.5);
                if (neededUlf > ulf) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x %.16f", Float.floatToRawIntBits(args.inValue), args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x %.16f", Float.floatToRawIntBits(args.inMinValue), args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x %.16f", Float.floatToRawIntBits(args.inMaxValue), args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x %.16f", Float.floatToRawIntBits(args.out), args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x %.16f", Float.floatToRawIntBits(arrayOut[i * 4 + j]), arrayOut[i * 4 + j]));
                    neededUlf = (int) (Math.abs(args.out - arrayOut[i * 4 + j]) / Math.ulp(args.out) + 0.5);
                    if (neededUlf > ulf) {
                        message.append(String.format(" FAILED, ulf needed %d, specified %d", neededUlf, ulf));
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampFloat4FloatFloatFloat4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsCharCharCharChar {
        public byte inValue;
        public byte inMinValue;
        public byte inMaxValue;
        public byte out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkClampCharCharCharChar() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0x5065bba87fc489e0L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0x5065bba87fc489e0L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0x5065bba87fc489e0L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampCharCharCharChar(inValue, out);
            verifyResultsClampCharCharCharChar(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampCharCharCharChar: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampCharCharCharChar(inValue, out);
            verifyResultsClampCharCharCharChar(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampCharCharCharChar: " + e.toString());
        }
    }

    private void verifyResultsClampCharCharCharChar(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 1];
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharCharChar args = new ArgumentsCharCharCharChar();
                args.inValue = arrayInValue[i];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %d", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %d", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampCharCharCharChar" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampChar2Char2Char2Char2() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 2, 0x69ba39920cb86e08L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 2, 0x69ba39920cb86e08L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 2, 0x69ba39920cb86e08L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampChar2Char2Char2Char2(inValue, out);
            verifyResultsClampChar2Char2Char2Char2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar2Char2Char2Char2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampChar2Char2Char2Char2(inValue, out);
            verifyResultsClampChar2Char2Char2Char2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar2Char2Char2Char2: " + e.toString());
        }
    }

    private void verifyResultsClampChar2Char2Char2Char2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 2];
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 2];
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 2];
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharCharChar args = new ArgumentsCharCharCharChar();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %d", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %d", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampChar2Char2Char2Char2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampChar3Char3Char3Char3() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 3, 0x3288563f173cc490L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 3, 0x3288563f173cc490L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 3, 0x3288563f173cc490L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampChar3Char3Char3Char3(inValue, out);
            verifyResultsClampChar3Char3Char3Char3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar3Char3Char3Char3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampChar3Char3Char3Char3(inValue, out);
            verifyResultsClampChar3Char3Char3Char3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar3Char3Char3Char3: " + e.toString());
        }
    }

    private void verifyResultsClampChar3Char3Char3Char3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 4];
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 4];
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharCharChar args = new ArgumentsCharCharCharChar();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %d", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %d", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampChar3Char3Char3Char3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampChar4Char4Char4Char4() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 4, 0xfb5672ec21c11b18L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 4, 0xfb5672ec21c11b18L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 4, 0xfb5672ec21c11b18L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampChar4Char4Char4Char4(inValue, out);
            verifyResultsClampChar4Char4Char4Char4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar4Char4Char4Char4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampChar4Char4Char4Char4(inValue, out);
            verifyResultsClampChar4Char4Char4Char4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar4Char4Char4Char4: " + e.toString());
        }
    }

    private void verifyResultsClampChar4Char4Char4Char4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 4];
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 4];
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharCharChar args = new ArgumentsCharCharCharChar();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %d", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %d", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampChar4Char4Char4Char4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsUcharUcharUcharUchar {
        public byte inValue;
        public byte inMinValue;
        public byte inMaxValue;
        public byte out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkClampUcharUcharUcharUchar() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0xc68ba167fca487c0L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0xc68ba167fca487c0L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0xc68ba167fca487c0L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUcharUcharUcharUchar(inValue, out);
            verifyResultsClampUcharUcharUcharUchar(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUcharUcharUcharUchar: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUcharUcharUcharUchar(inValue, out);
            verifyResultsClampUcharUcharUcharUchar(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUcharUcharUcharUchar: " + e.toString());
        }
    }

    private void verifyResultsClampUcharUcharUcharUchar(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 1];
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUcharUchar args = new ArgumentsUcharUcharUcharUchar();
                args.inValue = arrayInValue[i];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampUcharUcharUcharUchar" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampUchar2Uchar2Uchar2Uchar2() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 2, 0x4e3424d278a54dccL);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 2, 0x4e3424d278a54dccL);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 2, 0x4e3424d278a54dccL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUchar2Uchar2Uchar2Uchar2(inValue, out);
            verifyResultsClampUchar2Uchar2Uchar2Uchar2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar2Uchar2Uchar2Uchar2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUchar2Uchar2Uchar2Uchar2(inValue, out);
            verifyResultsClampUchar2Uchar2Uchar2Uchar2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar2Uchar2Uchar2Uchar2: " + e.toString());
        }
    }

    private void verifyResultsClampUchar2Uchar2Uchar2Uchar2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 2];
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 2];
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 2];
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUcharUchar args = new ArgumentsUcharUcharUcharUchar();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampUchar2Uchar2Uchar2Uchar2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampUchar3Uchar3Uchar3Uchar3() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 3, 0x29c2ce0c24346588L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 3, 0x29c2ce0c24346588L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 3, 0x29c2ce0c24346588L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUchar3Uchar3Uchar3Uchar3(inValue, out);
            verifyResultsClampUchar3Uchar3Uchar3Uchar3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar3Uchar3Uchar3Uchar3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUchar3Uchar3Uchar3Uchar3(inValue, out);
            verifyResultsClampUchar3Uchar3Uchar3Uchar3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar3Uchar3Uchar3Uchar3: " + e.toString());
        }
    }

    private void verifyResultsClampUchar3Uchar3Uchar3Uchar3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 4];
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 4];
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUcharUchar args = new ArgumentsUcharUcharUcharUchar();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampUchar3Uchar3Uchar3Uchar3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampUchar4Uchar4Uchar4Uchar4() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 4, 0x5517745cfc37d44L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 4, 0x5517745cfc37d44L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 4, 0x5517745cfc37d44L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUchar4Uchar4Uchar4Uchar4(inValue, out);
            verifyResultsClampUchar4Uchar4Uchar4Uchar4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar4Uchar4Uchar4Uchar4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUchar4Uchar4Uchar4Uchar4(inValue, out);
            verifyResultsClampUchar4Uchar4Uchar4Uchar4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar4Uchar4Uchar4Uchar4: " + e.toString());
        }
    }

    private void verifyResultsClampUchar4Uchar4Uchar4Uchar4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 4];
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 4];
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUcharUchar args = new ArgumentsUcharUcharUcharUchar();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampUchar4Uchar4Uchar4Uchar4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsShortShortShortShort {
        public short inValue;
        public short inMinValue;
        public short inMaxValue;
        public short out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkClampShortShortShortShort() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0xae1ae395299ec988L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0xae1ae395299ec988L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0xae1ae395299ec988L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampShortShortShortShort(inValue, out);
            verifyResultsClampShortShortShortShort(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShortShortShortShort: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampShortShortShortShort(inValue, out);
            verifyResultsClampShortShortShortShort(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShortShortShortShort: " + e.toString());
        }
    }

    private void verifyResultsClampShortShortShortShort(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 1];
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShortShort args = new ArgumentsShortShortShortShort();
                args.inValue = arrayInValue[i];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %d", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %d", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampShortShortShortShort" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampShort2Short2Short2Short2() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 2, 0xc640e567961f080L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 2, 0xc640e567961f080L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 2, 0xc640e567961f080L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampShort2Short2Short2Short2(inValue, out);
            verifyResultsClampShort2Short2Short2Short2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort2Short2Short2Short2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampShort2Short2Short2Short2(inValue, out);
            verifyResultsClampShort2Short2Short2Short2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort2Short2Short2Short2: " + e.toString());
        }
    }

    private void verifyResultsClampShort2Short2Short2Short2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 2];
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 2];
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 2];
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShortShort args = new ArgumentsShortShortShortShort();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %d", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %d", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampShort2Short2Short2Short2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampShort3Short3Short3Short3() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 3, 0xe7f2b79024f1083cL);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 3, 0xe7f2b79024f1083cL);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 3, 0xe7f2b79024f1083cL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampShort3Short3Short3Short3(inValue, out);
            verifyResultsClampShort3Short3Short3Short3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort3Short3Short3Short3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampShort3Short3Short3Short3(inValue, out);
            verifyResultsClampShort3Short3Short3Short3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort3Short3Short3Short3: " + e.toString());
        }
    }

    private void verifyResultsClampShort3Short3Short3Short3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 4];
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 4];
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShortShort args = new ArgumentsShortShortShortShort();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %d", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %d", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampShort3Short3Short3Short3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampShort4Short4Short4Short4() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 4, 0xc38160c9d0801ff8L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 4, 0xc38160c9d0801ff8L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 4, 0xc38160c9d0801ff8L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampShort4Short4Short4Short4(inValue, out);
            verifyResultsClampShort4Short4Short4Short4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort4Short4Short4Short4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampShort4Short4Short4Short4(inValue, out);
            verifyResultsClampShort4Short4Short4Short4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort4Short4Short4Short4: " + e.toString());
        }
    }

    private void verifyResultsClampShort4Short4Short4Short4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 4];
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 4];
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShortShort args = new ArgumentsShortShortShortShort();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %d", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %d", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampShort4Short4Short4Short4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsUshortUshortUshortUshort {
        public short inValue;
        public short inMinValue;
        public short inMaxValue;
        public short out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkClampUshortUshortUshortUshort() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0x3e4c5c80e2ef700cL);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0x3e4c5c80e2ef700cL);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0x3e4c5c80e2ef700cL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUshortUshortUshortUshort(inValue, out);
            verifyResultsClampUshortUshortUshortUshort(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshortUshortUshortUshort: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUshortUshortUshortUshort(inValue, out);
            verifyResultsClampUshortUshortUshortUshort(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshortUshortUshortUshort: " + e.toString());
        }
    }

    private void verifyResultsClampUshortUshortUshortUshort(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 1];
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshortUshort args = new ArgumentsUshortUshortUshortUshort();
                args.inValue = arrayInValue[i];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampUshortUshortUshortUshort" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampUshort2Ushort2Ushort2Ushort2() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 2, 0xf2e6b2dcac869df0L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 2, 0xf2e6b2dcac869df0L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 2, 0xf2e6b2dcac869df0L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUshort2Ushort2Ushort2Ushort2(inValue, out);
            verifyResultsClampUshort2Ushort2Ushort2Ushort2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort2Ushort2Ushort2Ushort2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUshort2Ushort2Ushort2Ushort2(inValue, out);
            verifyResultsClampUshort2Ushort2Ushort2Ushort2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort2Ushort2Ushort2Ushort2: " + e.toString());
        }
    }

    private void verifyResultsClampUshort2Ushort2Ushort2Ushort2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 2];
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 2];
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 2];
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshortUshort args = new ArgumentsUshortUshortUshortUshort();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampUshort2Ushort2Ushort2Ushort2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampUshort3Ushort3Ushort3Ushort3() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 3, 0x6d7975f06ef96e8L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 3, 0x6d7975f06ef96e8L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 3, 0x6d7975f06ef96e8L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUshort3Ushort3Ushort3Ushort3(inValue, out);
            verifyResultsClampUshort3Ushort3Ushort3Ushort3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort3Ushort3Ushort3Ushort3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUshort3Ushort3Ushort3Ushort3(inValue, out);
            verifyResultsClampUshort3Ushort3Ushort3Ushort3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort3Ushort3Ushort3Ushort3: " + e.toString());
        }
    }

    private void verifyResultsClampUshort3Ushort3Ushort3Ushort3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 4];
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 4];
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshortUshort args = new ArgumentsUshortUshortUshortUshort();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampUshort3Ushort3Ushort3Ushort3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampUshort4Ushort4Ushort4Ushort4() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 4, 0x1ac87be161588fe0L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 4, 0x1ac87be161588fe0L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 4, 0x1ac87be161588fe0L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUshort4Ushort4Ushort4Ushort4(inValue, out);
            verifyResultsClampUshort4Ushort4Ushort4Ushort4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort4Ushort4Ushort4Ushort4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUshort4Ushort4Ushort4Ushort4(inValue, out);
            verifyResultsClampUshort4Ushort4Ushort4Ushort4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort4Ushort4Ushort4Ushort4: " + e.toString());
        }
    }

    private void verifyResultsClampUshort4Ushort4Ushort4Ushort4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 4];
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 4];
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshortUshort args = new ArgumentsUshortUshortUshortUshort();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampUshort4Ushort4Ushort4Ushort4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsIntIntIntInt {
        public int inValue;
        public int inMinValue;
        public int inMaxValue;
        public int out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkClampIntIntIntInt() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0x9f1500ec34baf9b0L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0x9f1500ec34baf9b0L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0x9f1500ec34baf9b0L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampIntIntIntInt(inValue, out);
            verifyResultsClampIntIntIntInt(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampIntIntIntInt: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampIntIntIntInt(inValue, out);
            verifyResultsClampIntIntIntInt(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampIntIntIntInt: " + e.toString());
        }
    }

    private void verifyResultsClampIntIntIntInt(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 1];
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntIntInt args = new ArgumentsIntIntIntInt();
                args.inValue = arrayInValue[i];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %d", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %d", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampIntIntIntInt" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampInt2Int2Int2Int2() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 2, 0xf0d1159ef106aeccL);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 2, 0xf0d1159ef106aeccL);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 2, 0xf0d1159ef106aeccL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampInt2Int2Int2Int2(inValue, out);
            verifyResultsClampInt2Int2Int2Int2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt2Int2Int2Int2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampInt2Int2Int2Int2(inValue, out);
            verifyResultsClampInt2Int2Int2Int2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt2Int2Int2Int2: " + e.toString());
        }
    }

    private void verifyResultsClampInt2Int2Int2Int2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 2];
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 2];
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 2];
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntIntInt args = new ArgumentsIntIntIntInt();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %d", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %d", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampInt2Int2Int2Int2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampInt3Int3Int3Int3() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 3, 0x962a2573e2047118L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 3, 0x962a2573e2047118L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 3, 0x962a2573e2047118L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampInt3Int3Int3Int3(inValue, out);
            verifyResultsClampInt3Int3Int3Int3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt3Int3Int3Int3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampInt3Int3Int3Int3(inValue, out);
            verifyResultsClampInt3Int3Int3Int3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt3Int3Int3Int3: " + e.toString());
        }
    }

    private void verifyResultsClampInt3Int3Int3Int3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 4];
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 4];
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntIntInt args = new ArgumentsIntIntIntInt();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %d", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %d", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampInt3Int3Int3Int3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampInt4Int4Int4Int4() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 4, 0x3b833548d3023364L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 4, 0x3b833548d3023364L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 4, 0x3b833548d3023364L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampInt4Int4Int4Int4(inValue, out);
            verifyResultsClampInt4Int4Int4Int4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt4Int4Int4Int4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampInt4Int4Int4Int4(inValue, out);
            verifyResultsClampInt4Int4Int4Int4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt4Int4Int4Int4: " + e.toString());
        }
    }

    private void verifyResultsClampInt4Int4Int4Int4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 4];
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 4];
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntIntInt args = new ArgumentsIntIntIntInt();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %d", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %d", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampInt4Int4Int4Int4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsUintUintUintUint {
        public int inValue;
        public int inMinValue;
        public int inMaxValue;
        public int out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkClampUintUintUintUint() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0x3473de1b3a9276e0L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0x3473de1b3a9276e0L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0x3473de1b3a9276e0L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUintUintUintUint(inValue, out);
            verifyResultsClampUintUintUintUint(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUintUintUintUint: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUintUintUintUint(inValue, out);
            verifyResultsClampUintUintUintUint(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUintUintUintUint: " + e.toString());
        }
    }

    private void verifyResultsClampUintUintUintUint(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 1];
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUintUint args = new ArgumentsUintUintUintUint();
                args.inValue = arrayInValue[i];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampUintUintUintUint" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampUint2Uint2Uint2Uint2() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 2, 0xdf54b9e16f8b3808L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 2, 0xdf54b9e16f8b3808L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 2, 0xdf54b9e16f8b3808L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUint2Uint2Uint2Uint2(inValue, out);
            verifyResultsClampUint2Uint2Uint2Uint2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint2Uint2Uint2Uint2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUint2Uint2Uint2Uint2(inValue, out);
            verifyResultsClampUint2Uint2Uint2Uint2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint2Uint2Uint2Uint2: " + e.toString());
        }
    }

    private void verifyResultsClampUint2Uint2Uint2Uint2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 2];
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 2];
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 2];
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUintUint args = new ArgumentsUintUintUintUint();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampUint2Uint2Uint2Uint2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampUint3Uint3Uint3Uint3() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 3, 0xa822d68e7a0f8e90L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 3, 0xa822d68e7a0f8e90L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 3, 0xa822d68e7a0f8e90L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUint3Uint3Uint3Uint3(inValue, out);
            verifyResultsClampUint3Uint3Uint3Uint3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint3Uint3Uint3Uint3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUint3Uint3Uint3Uint3(inValue, out);
            verifyResultsClampUint3Uint3Uint3Uint3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint3Uint3Uint3Uint3: " + e.toString());
        }
    }

    private void verifyResultsClampUint3Uint3Uint3Uint3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 4];
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 4];
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUintUint args = new ArgumentsUintUintUintUint();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampUint3Uint3Uint3Uint3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampUint4Uint4Uint4Uint4() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 4, 0x70f0f33b8493e518L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 4, 0x70f0f33b8493e518L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 4, 0x70f0f33b8493e518L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUint4Uint4Uint4Uint4(inValue, out);
            verifyResultsClampUint4Uint4Uint4Uint4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint4Uint4Uint4Uint4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUint4Uint4Uint4Uint4(inValue, out);
            verifyResultsClampUint4Uint4Uint4Uint4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint4Uint4Uint4Uint4: " + e.toString());
        }
    }

    private void verifyResultsClampUint4Uint4Uint4Uint4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 4];
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 4];
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUintUint args = new ArgumentsUintUintUintUint();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampUint4Uint4Uint4Uint4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampChar2CharCharChar2() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 2, 0xf74149017b2ad71cL);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0xf74149017b2ad71cL);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0xf74149017b2ad71cL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampChar2CharCharChar2(inValue, out);
            verifyResultsClampChar2CharCharChar2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar2CharCharChar2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampChar2CharCharChar2(inValue, out);
            verifyResultsClampChar2CharCharChar2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar2CharCharChar2: " + e.toString());
        }
    }

    private void verifyResultsClampChar2CharCharChar2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 2];
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharCharChar args = new ArgumentsCharCharCharChar();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %d", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %d", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampChar2CharCharChar2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampChar3CharCharChar3() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 3, 0x679a7725410134d0L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0x679a7725410134d0L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0x679a7725410134d0L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampChar3CharCharChar3(inValue, out);
            verifyResultsClampChar3CharCharChar3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar3CharCharChar3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampChar3CharCharChar3(inValue, out);
            verifyResultsClampChar3CharCharChar3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar3CharCharChar3: " + e.toString());
        }
    }

    private void verifyResultsClampChar3CharCharChar3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharCharChar args = new ArgumentsCharCharCharChar();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %d", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %d", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampChar3CharCharChar3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampChar4CharCharChar4() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 4, 0xd7f3a54906d79284L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0xd7f3a54906d79284L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0xd7f3a54906d79284L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampChar4CharCharChar4(inValue, out);
            verifyResultsClampChar4CharCharChar4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar4CharCharChar4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampChar4CharCharChar4(inValue, out);
            verifyResultsClampChar4CharCharChar4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar4CharCharChar4: " + e.toString());
        }
    }

    private void verifyResultsClampChar4CharCharChar4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharCharChar args = new ArgumentsCharCharCharChar();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %d", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %d", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampChar4CharCharChar4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampUchar2UcharUcharUchar2() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 2, 0xb1bb06dfce29d93eL);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0xb1bb06dfce29d93eL);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0xb1bb06dfce29d93eL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUchar2UcharUcharUchar2(inValue, out);
            verifyResultsClampUchar2UcharUcharUchar2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar2UcharUcharUchar2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUchar2UcharUcharUchar2(inValue, out);
            verifyResultsClampUchar2UcharUcharUchar2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar2UcharUcharUchar2: " + e.toString());
        }
    }

    private void verifyResultsClampUchar2UcharUcharUchar2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 2];
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUcharUchar args = new ArgumentsUcharUcharUcharUchar();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampUchar2UcharUcharUchar2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampUchar3UcharUcharUchar3() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 3, 0x32cfcc5aa7763cf4L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0x32cfcc5aa7763cf4L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0x32cfcc5aa7763cf4L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUchar3UcharUcharUchar3(inValue, out);
            verifyResultsClampUchar3UcharUcharUchar3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar3UcharUcharUchar3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUchar3UcharUcharUchar3(inValue, out);
            verifyResultsClampUchar3UcharUcharUchar3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar3UcharUcharUchar3: " + e.toString());
        }
    }

    private void verifyResultsClampUchar3UcharUcharUchar3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUcharUchar args = new ArgumentsUcharUcharUcharUchar();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampUchar3UcharUcharUchar3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampUchar4UcharUcharUchar4() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 4, 0xb3e491d580c2a0aaL);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0xb3e491d580c2a0aaL);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0xb3e491d580c2a0aaL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUchar4UcharUcharUchar4(inValue, out);
            verifyResultsClampUchar4UcharUcharUchar4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar4UcharUcharUchar4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUchar4UcharUcharUchar4(inValue, out);
            verifyResultsClampUchar4UcharUcharUchar4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar4UcharUcharUchar4: " + e.toString());
        }
    }

    private void verifyResultsClampUchar4UcharUcharUchar4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUcharUchar args = new ArgumentsUcharUcharUcharUchar();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampUchar4UcharUcharUchar4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampShort2ShortShortShort2() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 2, 0x49ccdb9db709f6b4L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0x49ccdb9db709f6b4L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0x49ccdb9db709f6b4L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampShort2ShortShortShort2(inValue, out);
            verifyResultsClampShort2ShortShortShort2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort2ShortShortShort2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampShort2ShortShortShort2(inValue, out);
            verifyResultsClampShort2ShortShortShort2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort2ShortShortShort2: " + e.toString());
        }
    }

    private void verifyResultsClampShort2ShortShortShort2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 2];
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShortShort args = new ArgumentsShortShortShortShort();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %d", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %d", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampShort2ShortShortShort2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampShort3ShortShortShort3() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 3, 0xcae1a11890565a6aL);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0xcae1a11890565a6aL);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0xcae1a11890565a6aL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampShort3ShortShortShort3(inValue, out);
            verifyResultsClampShort3ShortShortShort3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort3ShortShortShort3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampShort3ShortShortShort3(inValue, out);
            verifyResultsClampShort3ShortShortShort3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort3ShortShortShort3: " + e.toString());
        }
    }

    private void verifyResultsClampShort3ShortShortShort3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShortShort args = new ArgumentsShortShortShortShort();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %d", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %d", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampShort3ShortShortShort3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampShort4ShortShortShort4() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 4, 0x4bf6669369a2be20L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0x4bf6669369a2be20L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0x4bf6669369a2be20L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampShort4ShortShortShort4(inValue, out);
            verifyResultsClampShort4ShortShortShort4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort4ShortShortShort4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampShort4ShortShortShort4(inValue, out);
            verifyResultsClampShort4ShortShortShort4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort4ShortShortShort4: " + e.toString());
        }
    }

    private void verifyResultsClampShort4ShortShortShort4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShortShort args = new ArgumentsShortShortShortShort();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %d", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %d", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampShort4ShortShortShort4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampUshort2UshortUshortUshort2() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 2, 0x9a431f7ce1e10402L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0x9a431f7ce1e10402L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0x9a431f7ce1e10402L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUshort2UshortUshortUshort2(inValue, out);
            verifyResultsClampUshort2UshortUshortUshort2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort2UshortUshortUshort2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUshort2UshortUshortUshort2(inValue, out);
            verifyResultsClampUshort2UshortUshortUshort2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort2UshortUshortUshort2: " + e.toString());
        }
    }

    private void verifyResultsClampUshort2UshortUshortUshort2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 2];
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshortUshort args = new ArgumentsUshortUshortUshortUshort();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampUshort2UshortUshortUshort2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampUshort3UshortUshortUshort3() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 3, 0xe0533d88d33946deL);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0xe0533d88d33946deL);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0xe0533d88d33946deL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUshort3UshortUshortUshort3(inValue, out);
            verifyResultsClampUshort3UshortUshortUshort3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort3UshortUshortUshort3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUshort3UshortUshortUshort3(inValue, out);
            verifyResultsClampUshort3UshortUshortUshort3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort3UshortUshortUshort3: " + e.toString());
        }
    }

    private void verifyResultsClampUshort3UshortUshortUshort3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshortUshort args = new ArgumentsUshortUshortUshortUshort();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampUshort3UshortUshortUshort3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampUshort4UshortUshortUshort4() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 4, 0x26635b94c49189baL);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0x26635b94c49189baL);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0x26635b94c49189baL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUshort4UshortUshortUshort4(inValue, out);
            verifyResultsClampUshort4UshortUshortUshort4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort4UshortUshortUshort4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUshort4UshortUshortUshort4(inValue, out);
            verifyResultsClampUshort4UshortUshortUshort4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort4UshortUshortUshort4: " + e.toString());
        }
    }

    private void verifyResultsClampUshort4UshortUshortUshort4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshortUshort args = new ArgumentsUshortUshortUshortUshort();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampUshort4UshortUshortUshort4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampInt2IntIntInt2() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 2, 0x7a141f41910a8976L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0x7a141f41910a8976L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0x7a141f41910a8976L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampInt2IntIntInt2(inValue, out);
            verifyResultsClampInt2IntIntInt2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt2IntIntInt2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampInt2IntIntInt2(inValue, out);
            verifyResultsClampInt2IntIntInt2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt2IntIntInt2: " + e.toString());
        }
    }

    private void verifyResultsClampInt2IntIntInt2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 2];
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntIntInt args = new ArgumentsIntIntIntInt();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %d", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %d", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampInt2IntIntInt2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampInt3IntIntInt3() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 3, 0xce773446a59095f4L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0xce773446a59095f4L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0xce773446a59095f4L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampInt3IntIntInt3(inValue, out);
            verifyResultsClampInt3IntIntInt3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt3IntIntInt3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampInt3IntIntInt3(inValue, out);
            verifyResultsClampInt3IntIntInt3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt3IntIntInt3: " + e.toString());
        }
    }

    private void verifyResultsClampInt3IntIntInt3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntIntInt args = new ArgumentsIntIntIntInt();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %d", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %d", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampInt3IntIntInt3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampInt4IntIntInt4() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 4, 0x22da494bba16a272L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0x22da494bba16a272L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0x22da494bba16a272L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampInt4IntIntInt4(inValue, out);
            verifyResultsClampInt4IntIntInt4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt4IntIntInt4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampInt4IntIntInt4(inValue, out);
            verifyResultsClampInt4IntIntInt4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt4IntIntInt4: " + e.toString());
        }
    }

    private void verifyResultsClampInt4IntIntInt4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntIntInt args = new ArgumentsIntIntIntInt();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %d", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %d", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampInt4IntIntInt4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampUint2UintUintUint2() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 2, 0xf3ff6ba92a95af9cL);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0xf3ff6ba92a95af9cL);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0xf3ff6ba92a95af9cL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUint2UintUintUint2(inValue, out);
            verifyResultsClampUint2UintUintUint2(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint2UintUintUint2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUint2UintUintUint2(inValue, out);
            verifyResultsClampUint2UintUintUint2(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint2UintUintUint2: " + e.toString());
        }
    }

    private void verifyResultsClampUint2UintUintUint2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 2];
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUintUint args = new ArgumentsUintUintUintUint();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampUint2UintUintUint2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampUint3UintUintUint3() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 3, 0x645899ccf06c0d50L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0x645899ccf06c0d50L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0x645899ccf06c0d50L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUint3UintUintUint3(inValue, out);
            verifyResultsClampUint3UintUintUint3(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint3UintUintUint3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUint3UintUintUint3(inValue, out);
            verifyResultsClampUint3UintUintUint3(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint3UintUintUint3: " + e.toString());
        }
    }

    private void verifyResultsClampUint3UintUintUint3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUintUint args = new ArgumentsUintUintUintUint();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampUint3UintUintUint3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClampUint4UintUintUint4() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 4, 0xd4b1c7f0b6426b04L);
        Allocation inMinValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0xd4b1c7f0b6426b04L);
        Allocation inMaxValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0xd4b1c7f0b6426b04L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUint4UintUintUint4(inValue, out);
            verifyResultsClampUint4UintUintUint4(inValue, inMinValue, inMaxValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint4UintUintUint4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUint4UintUintUint4(inValue, out);
            verifyResultsClampUint4UintUintUint4(inValue, inMinValue, inMaxValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint4UintUintUint4: " + e.toString());
        }
    }

    private void verifyResultsClampUint4UintUintUint4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 1];
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 1];
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUintUint args = new ArgumentsUintUintUintUint();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Input inMinValue: %x", args.inMinValue));
                    message.append("\n");
                    message.append(String.format("Input inMaxValue: %x", args.inMaxValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClampUint4UintUintUint4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public void testClamp() {
        checkClampFloatFloatFloatFloat();
        checkClampFloat2Float2Float2Float2();
        checkClampFloat3Float3Float3Float3();
        checkClampFloat4Float4Float4Float4();
        checkClampFloat2FloatFloatFloat2();
        checkClampFloat3FloatFloatFloat3();
        checkClampFloat4FloatFloatFloat4();
        checkClampCharCharCharChar();
        checkClampChar2Char2Char2Char2();
        checkClampChar3Char3Char3Char3();
        checkClampChar4Char4Char4Char4();
        checkClampUcharUcharUcharUchar();
        checkClampUchar2Uchar2Uchar2Uchar2();
        checkClampUchar3Uchar3Uchar3Uchar3();
        checkClampUchar4Uchar4Uchar4Uchar4();
        checkClampShortShortShortShort();
        checkClampShort2Short2Short2Short2();
        checkClampShort3Short3Short3Short3();
        checkClampShort4Short4Short4Short4();
        checkClampUshortUshortUshortUshort();
        checkClampUshort2Ushort2Ushort2Ushort2();
        checkClampUshort3Ushort3Ushort3Ushort3();
        checkClampUshort4Ushort4Ushort4Ushort4();
        checkClampIntIntIntInt();
        checkClampInt2Int2Int2Int2();
        checkClampInt3Int3Int3Int3();
        checkClampInt4Int4Int4Int4();
        checkClampUintUintUintUint();
        checkClampUint2Uint2Uint2Uint2();
        checkClampUint3Uint3Uint3Uint3();
        checkClampUint4Uint4Uint4Uint4();
        checkClampChar2CharCharChar2();
        checkClampChar3CharCharChar3();
        checkClampChar4CharCharChar4();
        checkClampUchar2UcharUcharUchar2();
        checkClampUchar3UcharUcharUchar3();
        checkClampUchar4UcharUcharUchar4();
        checkClampShort2ShortShortShort2();
        checkClampShort3ShortShortShort3();
        checkClampShort4ShortShortShort4();
        checkClampUshort2UshortUshortUshort2();
        checkClampUshort3UshortUshortUshort3();
        checkClampUshort4UshortUshortUshort4();
        checkClampInt2IntIntInt2();
        checkClampInt3IntIntInt3();
        checkClampInt4IntIntInt4();
        checkClampUint2UintUintUint2();
        checkClampUint3UintUintUint3();
        checkClampUint4UintUintUint4();
    }
}
