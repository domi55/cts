/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Don't edit this file!  It is auto-generated by frameworks/rs/api/gen_runtime.

package android.renderscript.cts;

import android.renderscript.Allocation;
import android.renderscript.RSRuntimeException;
import android.renderscript.Element;

public class GeneratedTestMax extends RSBaseCompute {

    private ScriptC_GeneratedTestMax script;
    private ScriptC_GeneratedTestMaxRelaxed scriptRelaxed;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        script = new ScriptC_GeneratedTestMax(mRS);
        scriptRelaxed = new ScriptC_GeneratedTestMaxRelaxed(mRS);
    }

    public class ArgumentsFloatFloatFloat {
        public float inA;
        public float inB;
        public Target.Floaty out;
    }

    private void checkMaxFloatFloatFloat() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0x2952d868c2162460l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0x2952d868c2162461l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 1), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxFloatFloatFloat(inA, out);
            verifyResultsMaxFloatFloatFloat(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloatFloatFloat: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxFloatFloatFloat(inA, out);
            verifyResultsMaxFloatFloatFloat(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloatFloatFloat: " + e.toString());
        }
    }

    private void verifyResultsMaxFloatFloatFloat(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        float[] arrayInA = new float[INPUTSIZE * 1];
        inA.copyTo(arrayInA);
        float[] arrayInB = new float[INPUTSIZE * 1];
        inB.copyTo(arrayInB);
        float[] arrayOut = new float[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloat args = new ArgumentsFloatFloatFloat();
                args.inA = arrayInA[i];
                args.inB = arrayInB[i];
                // Figure out what the outputs should have been.
                Target target = new Target(relaxed);
                CoreMathVerifier.computeMax(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(arrayOut[i * 1 + j])) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("%14.8g {%8x} %15a",
                            args.inA, Float.floatToRawIntBits(args.inA), args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("%14.8g {%8x} %15a",
                            args.inB, Float.floatToRawIntBits(args.inB), args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(args.out.toString());
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("%14.8g {%8x} %15a",
                            arrayOut[i * 1 + j], Float.floatToRawIntBits(arrayOut[i * 1 + j]), arrayOut[i * 1 + j]));
                    if (!args.out.couldBe(arrayOut[i * 1 + j])) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxFloatFloatFloat" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxFloat2Float2Float2() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 2, 0xc6031e7536addadal, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 2, 0xc6031e7536addadbl, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 2), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxFloat2Float2Float2(inA, out);
            verifyResultsMaxFloat2Float2Float2(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloat2Float2Float2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxFloat2Float2Float2(inA, out);
            verifyResultsMaxFloat2Float2Float2(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloat2Float2Float2: " + e.toString());
        }
    }

    private void verifyResultsMaxFloat2Float2Float2(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        float[] arrayInA = new float[INPUTSIZE * 2];
        inA.copyTo(arrayInA);
        float[] arrayInB = new float[INPUTSIZE * 2];
        inB.copyTo(arrayInB);
        float[] arrayOut = new float[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloat args = new ArgumentsFloatFloatFloat();
                args.inA = arrayInA[i * 2 + j];
                args.inB = arrayInB[i * 2 + j];
                // Figure out what the outputs should have been.
                Target target = new Target(relaxed);
                CoreMathVerifier.computeMax(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(arrayOut[i * 2 + j])) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("%14.8g {%8x} %15a",
                            args.inA, Float.floatToRawIntBits(args.inA), args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("%14.8g {%8x} %15a",
                            args.inB, Float.floatToRawIntBits(args.inB), args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(args.out.toString());
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("%14.8g {%8x} %15a",
                            arrayOut[i * 2 + j], Float.floatToRawIntBits(arrayOut[i * 2 + j]), arrayOut[i * 2 + j]));
                    if (!args.out.couldBe(arrayOut[i * 2 + j])) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxFloat2Float2Float2" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxFloat3Float3Float3() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 3, 0x1a67fc95388bdc7bl, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 3, 0x1a67fc95388bdc7cl, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 3), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxFloat3Float3Float3(inA, out);
            verifyResultsMaxFloat3Float3Float3(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloat3Float3Float3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxFloat3Float3Float3(inA, out);
            verifyResultsMaxFloat3Float3Float3(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloat3Float3Float3: " + e.toString());
        }
    }

    private void verifyResultsMaxFloat3Float3Float3(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        float[] arrayInA = new float[INPUTSIZE * 4];
        inA.copyTo(arrayInA);
        float[] arrayInB = new float[INPUTSIZE * 4];
        inB.copyTo(arrayInB);
        float[] arrayOut = new float[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloat args = new ArgumentsFloatFloatFloat();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                Target target = new Target(relaxed);
                CoreMathVerifier.computeMax(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("%14.8g {%8x} %15a",
                            args.inA, Float.floatToRawIntBits(args.inA), args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("%14.8g {%8x} %15a",
                            args.inB, Float.floatToRawIntBits(args.inB), args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(args.out.toString());
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("%14.8g {%8x} %15a",
                            arrayOut[i * 4 + j], Float.floatToRawIntBits(arrayOut[i * 4 + j]), arrayOut[i * 4 + j]));
                    if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxFloat3Float3Float3" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxFloat4Float4Float4() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 4, 0x6eccdab53a69de1cl, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 4, 0x6eccdab53a69de1dl, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 4), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxFloat4Float4Float4(inA, out);
            verifyResultsMaxFloat4Float4Float4(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloat4Float4Float4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxFloat4Float4Float4(inA, out);
            verifyResultsMaxFloat4Float4Float4(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloat4Float4Float4: " + e.toString());
        }
    }

    private void verifyResultsMaxFloat4Float4Float4(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        float[] arrayInA = new float[INPUTSIZE * 4];
        inA.copyTo(arrayInA);
        float[] arrayInB = new float[INPUTSIZE * 4];
        inB.copyTo(arrayInB);
        float[] arrayOut = new float[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloat args = new ArgumentsFloatFloatFloat();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                Target target = new Target(relaxed);
                CoreMathVerifier.computeMax(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("%14.8g {%8x} %15a",
                            args.inA, Float.floatToRawIntBits(args.inA), args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("%14.8g {%8x} %15a",
                            args.inB, Float.floatToRawIntBits(args.inB), args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(args.out.toString());
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("%14.8g {%8x} %15a",
                            arrayOut[i * 4 + j], Float.floatToRawIntBits(arrayOut[i * 4 + j]), arrayOut[i * 4 + j]));
                    if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxFloat4Float4Float4" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsCharCharChar {
        public byte inA;
        public byte inB;
        public byte out;
    }

    private void checkMaxCharCharChar() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0x5f77cf3cb6405876l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0x5f77cf3cb6405877l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 1), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxCharCharChar(inA, out);
            verifyResultsMaxCharCharChar(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxCharCharChar: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxCharCharChar(inA, out);
            verifyResultsMaxCharCharChar(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxCharCharChar: " + e.toString());
        }
    }

    private void verifyResultsMaxCharCharChar(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        byte[] arrayInA = new byte[INPUTSIZE * 1];
        inA.copyTo(arrayInA);
        byte[] arrayInB = new byte[INPUTSIZE * 1];
        inB.copyTo(arrayInB);
        byte[] arrayOut = new byte[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharChar args = new ArgumentsCharCharChar();
                args.inA = arrayInA[i];
                args.inB = arrayInB[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("%d", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("%d", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("%d", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("%d", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxCharCharChar" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxChar2Char2Char2() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 2, 0x94dd090a19e42804l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 2, 0x94dd090a19e42805l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 2), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxChar2Char2Char2(inA, out);
            verifyResultsMaxChar2Char2Char2(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxChar2Char2Char2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxChar2Char2Char2(inA, out);
            verifyResultsMaxChar2Char2Char2(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxChar2Char2Char2: " + e.toString());
        }
    }

    private void verifyResultsMaxChar2Char2Char2(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        byte[] arrayInA = new byte[INPUTSIZE * 2];
        inA.copyTo(arrayInA);
        byte[] arrayInB = new byte[INPUTSIZE * 2];
        inB.copyTo(arrayInB);
        byte[] arrayOut = new byte[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharChar args = new ArgumentsCharCharChar();
                args.inA = arrayInA[i * 2 + j];
                args.inB = arrayInB[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("%d", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("%d", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("%d", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("%d", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxChar2Char2Char2" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxChar3Char3Char3() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 3, 0xba9188f3788338d3l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 3, 0xba9188f3788338d4l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 3), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxChar3Char3Char3(inA, out);
            verifyResultsMaxChar3Char3Char3(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxChar3Char3Char3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxChar3Char3Char3(inA, out);
            verifyResultsMaxChar3Char3Char3(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxChar3Char3Char3: " + e.toString());
        }
    }

    private void verifyResultsMaxChar3Char3Char3(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        byte[] arrayInA = new byte[INPUTSIZE * 4];
        inA.copyTo(arrayInA);
        byte[] arrayInB = new byte[INPUTSIZE * 4];
        inB.copyTo(arrayInB);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharChar args = new ArgumentsCharCharChar();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("%d", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("%d", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("%d", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("%d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxChar3Char3Char3" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxChar4Char4Char4() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 4, 0xe04608dcd72249a2l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 4, 0xe04608dcd72249a3l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 4), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxChar4Char4Char4(inA, out);
            verifyResultsMaxChar4Char4Char4(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxChar4Char4Char4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxChar4Char4Char4(inA, out);
            verifyResultsMaxChar4Char4Char4(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxChar4Char4Char4: " + e.toString());
        }
    }

    private void verifyResultsMaxChar4Char4Char4(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        byte[] arrayInA = new byte[INPUTSIZE * 4];
        inA.copyTo(arrayInA);
        byte[] arrayInB = new byte[INPUTSIZE * 4];
        inB.copyTo(arrayInB);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharChar args = new ArgumentsCharCharChar();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("%d", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("%d", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("%d", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("%d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxChar4Char4Char4" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsUcharUcharUchar {
        public byte inA;
        public byte inB;
        public byte out;
    }

    private void checkMaxUcharUcharUchar() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0x800f9948853a162dl, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0x800f9948853a162el, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 1), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUcharUcharUchar(inA, out);
            verifyResultsMaxUcharUcharUchar(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUcharUcharUchar: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUcharUcharUchar(inA, out);
            verifyResultsMaxUcharUcharUchar(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUcharUcharUchar: " + e.toString());
        }
    }

    private void verifyResultsMaxUcharUcharUchar(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        byte[] arrayInA = new byte[INPUTSIZE * 1];
        inA.copyTo(arrayInA);
        byte[] arrayInB = new byte[INPUTSIZE * 1];
        inB.copyTo(arrayInB);
        byte[] arrayOut = new byte[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUchar args = new ArgumentsUcharUcharUchar();
                args.inA = arrayInA[i];
                args.inB = arrayInB[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("0x%x", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("0x%x", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("0x%x", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("0x%x", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUcharUcharUchar" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxUchar2Uchar2Uchar2() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 2, 0xd31d5735b7e9a9dbl, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 2, 0xd31d5735b7e9a9dcl, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 2), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUchar2Uchar2Uchar2(inA, out);
            verifyResultsMaxUchar2Uchar2Uchar2(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUchar2Uchar2Uchar2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUchar2Uchar2Uchar2(inA, out);
            verifyResultsMaxUchar2Uchar2Uchar2(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUchar2Uchar2Uchar2: " + e.toString());
        }
    }

    private void verifyResultsMaxUchar2Uchar2Uchar2(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        byte[] arrayInA = new byte[INPUTSIZE * 2];
        inA.copyTo(arrayInA);
        byte[] arrayInB = new byte[INPUTSIZE * 2];
        inB.copyTo(arrayInB);
        byte[] arrayOut = new byte[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUchar args = new ArgumentsUcharUcharUchar();
                args.inA = arrayInA[i * 2 + j];
                args.inB = arrayInB[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("0x%x", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("0x%x", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("0x%x", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("0x%x", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUchar2Uchar2Uchar2" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxUchar3Uchar3Uchar3() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 3, 0x27823555b9c7ab7cl, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 3, 0x27823555b9c7ab7dl, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 3), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUchar3Uchar3Uchar3(inA, out);
            verifyResultsMaxUchar3Uchar3Uchar3(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUchar3Uchar3Uchar3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUchar3Uchar3Uchar3(inA, out);
            verifyResultsMaxUchar3Uchar3Uchar3(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUchar3Uchar3Uchar3: " + e.toString());
        }
    }

    private void verifyResultsMaxUchar3Uchar3Uchar3(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        byte[] arrayInA = new byte[INPUTSIZE * 4];
        inA.copyTo(arrayInA);
        byte[] arrayInB = new byte[INPUTSIZE * 4];
        inB.copyTo(arrayInB);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUchar args = new ArgumentsUcharUcharUchar();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("0x%x", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("0x%x", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("0x%x", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("0x%x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUchar3Uchar3Uchar3" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxUchar4Uchar4Uchar4() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 4, 0x7be71375bba5ad1dl, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 4, 0x7be71375bba5ad1el, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 4), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUchar4Uchar4Uchar4(inA, out);
            verifyResultsMaxUchar4Uchar4Uchar4(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUchar4Uchar4Uchar4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUchar4Uchar4Uchar4(inA, out);
            verifyResultsMaxUchar4Uchar4Uchar4(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUchar4Uchar4Uchar4: " + e.toString());
        }
    }

    private void verifyResultsMaxUchar4Uchar4Uchar4(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        byte[] arrayInA = new byte[INPUTSIZE * 4];
        inA.copyTo(arrayInA);
        byte[] arrayInB = new byte[INPUTSIZE * 4];
        inB.copyTo(arrayInB);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUchar args = new ArgumentsUcharUcharUchar();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("0x%x", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("0x%x", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("0x%x", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("0x%x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUchar4Uchar4Uchar4" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsShortShortShort {
        public short inA;
        public short inB;
        public short out;
    }

    private void checkMaxShortShortShort() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0x920335e143b57294l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0x920335e143b57295l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 1), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxShortShortShort(inA, out);
            verifyResultsMaxShortShortShort(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxShortShortShort: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxShortShortShort(inA, out);
            verifyResultsMaxShortShortShort(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxShortShortShort: " + e.toString());
        }
    }

    private void verifyResultsMaxShortShortShort(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        short[] arrayInA = new short[INPUTSIZE * 1];
        inA.copyTo(arrayInA);
        short[] arrayInB = new short[INPUTSIZE * 1];
        inB.copyTo(arrayInB);
        short[] arrayOut = new short[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShort args = new ArgumentsShortShortShort();
                args.inA = arrayInA[i];
                args.inB = arrayInB[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("%d", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("%d", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("%d", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("%d", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxShortShortShort" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxShort2Short2Short2() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 2, 0x42e9d46b56ecb9del, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 2, 0x42e9d46b56ecb9dfl, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 2), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxShort2Short2Short2(inA, out);
            verifyResultsMaxShort2Short2Short2(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxShort2Short2Short2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxShort2Short2Short2(inA, out);
            verifyResultsMaxShort2Short2Short2(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxShort2Short2Short2: " + e.toString());
        }
    }

    private void verifyResultsMaxShort2Short2Short2(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        short[] arrayInA = new short[INPUTSIZE * 2];
        inA.copyTo(arrayInA);
        short[] arrayInB = new short[INPUTSIZE * 2];
        inB.copyTo(arrayInB);
        short[] arrayOut = new short[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShort args = new ArgumentsShortShortShort();
                args.inA = arrayInA[i * 2 + j];
                args.inB = arrayInB[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("%d", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("%d", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("%d", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("%d", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxShort2Short2Short2" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxShort3Short3Short3() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 3, 0x974eb28b58cabb7fl, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 3, 0x974eb28b58cabb80l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 3), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxShort3Short3Short3(inA, out);
            verifyResultsMaxShort3Short3Short3(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxShort3Short3Short3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxShort3Short3Short3(inA, out);
            verifyResultsMaxShort3Short3Short3(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxShort3Short3Short3: " + e.toString());
        }
    }

    private void verifyResultsMaxShort3Short3Short3(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        short[] arrayInA = new short[INPUTSIZE * 4];
        inA.copyTo(arrayInA);
        short[] arrayInB = new short[INPUTSIZE * 4];
        inB.copyTo(arrayInB);
        short[] arrayOut = new short[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShort args = new ArgumentsShortShortShort();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("%d", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("%d", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("%d", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("%d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxShort3Short3Short3" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxShort4Short4Short4() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 4, 0xebb390ab5aa8bd20l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 4, 0xebb390ab5aa8bd21l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 4), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxShort4Short4Short4(inA, out);
            verifyResultsMaxShort4Short4Short4(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxShort4Short4Short4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxShort4Short4Short4(inA, out);
            verifyResultsMaxShort4Short4Short4(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxShort4Short4Short4: " + e.toString());
        }
    }

    private void verifyResultsMaxShort4Short4Short4(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        short[] arrayInA = new short[INPUTSIZE * 4];
        inA.copyTo(arrayInA);
        short[] arrayInB = new short[INPUTSIZE * 4];
        inB.copyTo(arrayInB);
        short[] arrayOut = new short[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShort args = new ArgumentsShortShortShort();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("%d", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("%d", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("%d", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("%d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxShort4Short4Short4" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsUshortUshortUshort {
        public short inA;
        public short inB;
        public short out;
    }

    private void checkMaxUshortUshortUshort() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0x8f869c73b947704bl, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0x8f869c73b947704cl, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 1), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUshortUshortUshort(inA, out);
            verifyResultsMaxUshortUshortUshort(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUshortUshortUshort: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUshortUshortUshort(inA, out);
            verifyResultsMaxUshortUshortUshort(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUshortUshortUshort: " + e.toString());
        }
    }

    private void verifyResultsMaxUshortUshortUshort(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        short[] arrayInA = new short[INPUTSIZE * 1];
        inA.copyTo(arrayInA);
        short[] arrayInB = new short[INPUTSIZE * 1];
        inB.copyTo(arrayInB);
        short[] arrayOut = new short[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshort args = new ArgumentsUshortUshortUshort();
                args.inA = arrayInA[i];
                args.inB = arrayInB[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("0x%x", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("0x%x", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("0x%x", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("0x%x", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUshortUshortUshort" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxUshort2Ushort2Ushort2() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 2, 0xbe3c50e6150b1f95l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 2, 0xbe3c50e6150b1f96l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 2), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUshort2Ushort2Ushort2(inA, out);
            verifyResultsMaxUshort2Ushort2Ushort2(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUshort2Ushort2Ushort2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUshort2Ushort2Ushort2(inA, out);
            verifyResultsMaxUshort2Ushort2Ushort2(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUshort2Ushort2Ushort2: " + e.toString());
        }
    }

    private void verifyResultsMaxUshort2Ushort2Ushort2(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        short[] arrayInA = new short[INPUTSIZE * 2];
        inA.copyTo(arrayInA);
        short[] arrayInB = new short[INPUTSIZE * 2];
        inB.copyTo(arrayInB);
        short[] arrayOut = new short[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshort args = new ArgumentsUshortUshortUshort();
                args.inA = arrayInA[i * 2 + j];
                args.inB = arrayInB[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("0x%x", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("0x%x", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("0x%x", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("0x%x", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUshort2Ushort2Ushort2" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxUshort3Ushort3Ushort3() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 3, 0x3e2be9df5df0112cl, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 3, 0x3e2be9df5df0112dl, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 3), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUshort3Ushort3Ushort3(inA, out);
            verifyResultsMaxUshort3Ushort3Ushort3(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUshort3Ushort3Ushort3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUshort3Ushort3Ushort3(inA, out);
            verifyResultsMaxUshort3Ushort3Ushort3(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUshort3Ushort3Ushort3: " + e.toString());
        }
    }

    private void verifyResultsMaxUshort3Ushort3Ushort3(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        short[] arrayInA = new short[INPUTSIZE * 4];
        inA.copyTo(arrayInA);
        short[] arrayInB = new short[INPUTSIZE * 4];
        inB.copyTo(arrayInB);
        short[] arrayOut = new short[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshort args = new ArgumentsUshortUshortUshort();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("0x%x", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("0x%x", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("0x%x", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("0x%x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUshort3Ushort3Ushort3" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxUshort4Ushort4Ushort4() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 4, 0xbe1b82d8a6d502c3l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 4, 0xbe1b82d8a6d502c4l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 4), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUshort4Ushort4Ushort4(inA, out);
            verifyResultsMaxUshort4Ushort4Ushort4(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUshort4Ushort4Ushort4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUshort4Ushort4Ushort4(inA, out);
            verifyResultsMaxUshort4Ushort4Ushort4(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUshort4Ushort4Ushort4: " + e.toString());
        }
    }

    private void verifyResultsMaxUshort4Ushort4Ushort4(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        short[] arrayInA = new short[INPUTSIZE * 4];
        inA.copyTo(arrayInA);
        short[] arrayInB = new short[INPUTSIZE * 4];
        inB.copyTo(arrayInB);
        short[] arrayOut = new short[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshort args = new ArgumentsUshortUshortUshort();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("0x%x", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("0x%x", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("0x%x", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("0x%x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUshort4Ushort4Ushort4" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsIntIntInt {
        public int inA;
        public int inB;
        public int out;
    }

    private void checkMaxIntIntInt() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0x773d0d60e43d0fa9l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0x773d0d60e43d0faal, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 1), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxIntIntInt(inA, out);
            verifyResultsMaxIntIntInt(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxIntIntInt: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxIntIntInt(inA, out);
            verifyResultsMaxIntIntInt(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxIntIntInt: " + e.toString());
        }
    }

    private void verifyResultsMaxIntIntInt(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        int[] arrayInA = new int[INPUTSIZE * 1];
        inA.copyTo(arrayInA);
        int[] arrayInB = new int[INPUTSIZE * 1];
        inB.copyTo(arrayInB);
        int[] arrayOut = new int[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntInt args = new ArgumentsIntIntInt();
                args.inA = arrayInA[i];
                args.inB = arrayInB[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("%d", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("%d", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("%d", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("%d", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxIntIntInt" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxInt2Int2Int2() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 2, 0x32815a01bb9dccd7l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 2, 0x32815a01bb9dccd8l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 2), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxInt2Int2Int2(inA, out);
            verifyResultsMaxInt2Int2Int2(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxInt2Int2Int2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxInt2Int2Int2(inA, out);
            verifyResultsMaxInt2Int2Int2(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxInt2Int2Int2: " + e.toString());
        }
    }

    private void verifyResultsMaxInt2Int2Int2(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        int[] arrayInA = new int[INPUTSIZE * 2];
        inA.copyTo(arrayInA);
        int[] arrayInB = new int[INPUTSIZE * 2];
        inB.copyTo(arrayInB);
        int[] arrayOut = new int[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntInt args = new ArgumentsIntIntInt();
                args.inA = arrayInA[i * 2 + j];
                args.inB = arrayInB[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("%d", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("%d", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("%d", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("%d", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxInt2Int2Int2" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxInt3Int3Int3() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 3, 0x3f66ddfc867314c0l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 3, 0x3f66ddfc867314c1l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 3), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxInt3Int3Int3(inA, out);
            verifyResultsMaxInt3Int3Int3(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxInt3Int3Int3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxInt3Int3Int3(inA, out);
            verifyResultsMaxInt3Int3Int3(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxInt3Int3Int3: " + e.toString());
        }
    }

    private void verifyResultsMaxInt3Int3Int3(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        int[] arrayInA = new int[INPUTSIZE * 4];
        inA.copyTo(arrayInA);
        int[] arrayInB = new int[INPUTSIZE * 4];
        inB.copyTo(arrayInB);
        int[] arrayOut = new int[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntInt args = new ArgumentsIntIntInt();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("%d", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("%d", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("%d", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("%d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxInt3Int3Int3" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxInt4Int4Int4() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 4, 0x4c4c61f751485ca9l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 4, 0x4c4c61f751485caal, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 4), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxInt4Int4Int4(inA, out);
            verifyResultsMaxInt4Int4Int4(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxInt4Int4Int4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxInt4Int4Int4(inA, out);
            verifyResultsMaxInt4Int4Int4(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxInt4Int4Int4: " + e.toString());
        }
    }

    private void verifyResultsMaxInt4Int4Int4(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        int[] arrayInA = new int[INPUTSIZE * 4];
        inA.copyTo(arrayInA);
        int[] arrayInB = new int[INPUTSIZE * 4];
        inB.copyTo(arrayInB);
        int[] arrayOut = new int[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntInt args = new ArgumentsIntIntInt();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("%d", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("%d", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("%d", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("%d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxInt4Int4Int4" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsUintUintUint {
        public int inA;
        public int inB;
        public int out;
    }

    private void checkMaxUintUintUint() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0xcd24e58385f73e36l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0xcd24e58385f73e37l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 1), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUintUintUint(inA, out);
            verifyResultsMaxUintUintUint(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUintUintUint: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUintUintUint(inA, out);
            verifyResultsMaxUintUintUint(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUintUintUint: " + e.toString());
        }
    }

    private void verifyResultsMaxUintUintUint(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        int[] arrayInA = new int[INPUTSIZE * 1];
        inA.copyTo(arrayInA);
        int[] arrayInB = new int[INPUTSIZE * 1];
        inB.copyTo(arrayInB);
        int[] arrayOut = new int[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUint args = new ArgumentsUintUintUint();
                args.inA = arrayInA[i];
                args.inB = arrayInB[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("0x%x", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("0x%x", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("0x%x", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("0x%x", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUintUintUint" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxUint2Uint2Uint2() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 2, 0xbd5747860e84d6c4l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 2, 0xbd5747860e84d6c5l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 2), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUint2Uint2Uint2(inA, out);
            verifyResultsMaxUint2Uint2Uint2(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUint2Uint2Uint2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUint2Uint2Uint2(inA, out);
            verifyResultsMaxUint2Uint2Uint2(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUint2Uint2Uint2: " + e.toString());
        }
    }

    private void verifyResultsMaxUint2Uint2Uint2(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        int[] arrayInA = new int[INPUTSIZE * 2];
        inA.copyTo(arrayInA);
        int[] arrayInB = new int[INPUTSIZE * 2];
        inB.copyTo(arrayInB);
        int[] arrayOut = new int[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUint args = new ArgumentsUintUintUint();
                args.inA = arrayInA[i * 2 + j];
                args.inB = arrayInB[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("0x%x", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("0x%x", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("0x%x", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("0x%x", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUint2Uint2Uint2" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxUint3Uint3Uint3() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 3, 0xe30bc76f6d23e793l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 3, 0xe30bc76f6d23e794l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 3), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUint3Uint3Uint3(inA, out);
            verifyResultsMaxUint3Uint3Uint3(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUint3Uint3Uint3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUint3Uint3Uint3(inA, out);
            verifyResultsMaxUint3Uint3Uint3(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUint3Uint3Uint3: " + e.toString());
        }
    }

    private void verifyResultsMaxUint3Uint3Uint3(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        int[] arrayInA = new int[INPUTSIZE * 4];
        inA.copyTo(arrayInA);
        int[] arrayInB = new int[INPUTSIZE * 4];
        inB.copyTo(arrayInB);
        int[] arrayOut = new int[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUint args = new ArgumentsUintUintUint();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("0x%x", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("0x%x", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("0x%x", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("0x%x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUint3Uint3Uint3" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxUint4Uint4Uint4() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 4, 0x8c04758cbc2f862l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 4, 0x8c04758cbc2f863l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 4), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUint4Uint4Uint4(inA, out);
            verifyResultsMaxUint4Uint4Uint4(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUint4Uint4Uint4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUint4Uint4Uint4(inA, out);
            verifyResultsMaxUint4Uint4Uint4(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUint4Uint4Uint4: " + e.toString());
        }
    }

    private void verifyResultsMaxUint4Uint4Uint4(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        int[] arrayInA = new int[INPUTSIZE * 4];
        inA.copyTo(arrayInA);
        int[] arrayInB = new int[INPUTSIZE * 4];
        inB.copyTo(arrayInB);
        int[] arrayOut = new int[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUint args = new ArgumentsUintUintUint();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("0x%x", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("0x%x", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("0x%x", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("0x%x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUint4Uint4Uint4" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsLongLongLong {
        public long inA;
        public long inB;
        public long out;
    }

    private void checkMaxLongLongLong() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 1, 0x542587285eceb84l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 1, 0x542587285eceb85l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 1), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxLongLongLong(inA, out);
            verifyResultsMaxLongLongLong(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxLongLongLong: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxLongLongLong(inA, out);
            verifyResultsMaxLongLongLong(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxLongLongLong: " + e.toString());
        }
    }

    private void verifyResultsMaxLongLongLong(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        long[] arrayInA = new long[INPUTSIZE * 1];
        inA.copyTo(arrayInA);
        long[] arrayInB = new long[INPUTSIZE * 1];
        inB.copyTo(arrayInB);
        long[] arrayOut = new long[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsLongLongLong args = new ArgumentsLongLongLong();
                args.inA = arrayInA[i];
                args.inB = arrayInB[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("%d", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("%d", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("%d", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("%d", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxLongLongLong" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxLong2Long2Long2() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 2, 0xc5c0bac4c249c9dal, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 2, 0xc5c0bac4c249c9dbl, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 2), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxLong2Long2Long2(inA, out);
            verifyResultsMaxLong2Long2Long2(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxLong2Long2Long2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxLong2Long2Long2(inA, out);
            verifyResultsMaxLong2Long2Long2(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxLong2Long2Long2: " + e.toString());
        }
    }

    private void verifyResultsMaxLong2Long2Long2(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        long[] arrayInA = new long[INPUTSIZE * 2];
        inA.copyTo(arrayInA);
        long[] arrayInB = new long[INPUTSIZE * 2];
        inB.copyTo(arrayInB);
        long[] arrayOut = new long[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsLongLongLong args = new ArgumentsLongLongLong();
                args.inA = arrayInA[i * 2 + j];
                args.inB = arrayInB[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("%d", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("%d", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("%d", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("%d", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxLong2Long2Long2" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxLong3Long3Long3() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 3, 0xeb753aae20e8daa9l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 3, 0xeb753aae20e8daaal, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 3), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxLong3Long3Long3(inA, out);
            verifyResultsMaxLong3Long3Long3(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxLong3Long3Long3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxLong3Long3Long3(inA, out);
            verifyResultsMaxLong3Long3Long3(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxLong3Long3Long3: " + e.toString());
        }
    }

    private void verifyResultsMaxLong3Long3Long3(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        long[] arrayInA = new long[INPUTSIZE * 4];
        inA.copyTo(arrayInA);
        long[] arrayInB = new long[INPUTSIZE * 4];
        inB.copyTo(arrayInB);
        long[] arrayOut = new long[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsLongLongLong args = new ArgumentsLongLongLong();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("%d", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("%d", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("%d", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("%d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxLong3Long3Long3" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxLong4Long4Long4() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 4, 0x1129ba977f87eb78l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 4, 0x1129ba977f87eb79l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 4), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxLong4Long4Long4(inA, out);
            verifyResultsMaxLong4Long4Long4(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxLong4Long4Long4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxLong4Long4Long4(inA, out);
            verifyResultsMaxLong4Long4Long4(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxLong4Long4Long4: " + e.toString());
        }
    }

    private void verifyResultsMaxLong4Long4Long4(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        long[] arrayInA = new long[INPUTSIZE * 4];
        inA.copyTo(arrayInA);
        long[] arrayInB = new long[INPUTSIZE * 4];
        inB.copyTo(arrayInB);
        long[] arrayOut = new long[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsLongLongLong args = new ArgumentsLongLongLong();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("%d", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("%d", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("%d", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("%d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxLong4Long4Long4" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsUlongUlongUlong {
        public long inA;
        public long inB;
        public long out;
    }

    private void checkMaxUlongUlongUlong() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 1, 0x8d1ad8f38f18baafl, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 1, 0x8d1ad8f38f18bab0l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 1), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUlongUlongUlong(inA, out);
            verifyResultsMaxUlongUlongUlong(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUlongUlongUlong: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUlongUlongUlong(inA, out);
            verifyResultsMaxUlongUlongUlong(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUlongUlongUlong: " + e.toString());
        }
    }

    private void verifyResultsMaxUlongUlongUlong(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        long[] arrayInA = new long[INPUTSIZE * 1];
        inA.copyTo(arrayInA);
        long[] arrayInB = new long[INPUTSIZE * 1];
        inB.copyTo(arrayInB);
        long[] arrayOut = new long[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUlongUlongUlong args = new ArgumentsUlongUlongUlong();
                args.inA = arrayInA[i];
                args.inB = arrayInB[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("0x%x", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("0x%x", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("0x%x", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("0x%x", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUlongUlongUlong" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxUlong2Ulong2Ulong2() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 2, 0x6e2049a55946bc65l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 2, 0x6e2049a55946bc66l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 2), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUlong2Ulong2Ulong2(inA, out);
            verifyResultsMaxUlong2Ulong2Ulong2(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUlong2Ulong2Ulong2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUlong2Ulong2Ulong2(inA, out);
            verifyResultsMaxUlong2Ulong2Ulong2(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUlong2Ulong2Ulong2: " + e.toString());
        }
    }

    private void verifyResultsMaxUlong2Ulong2Ulong2(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        long[] arrayInA = new long[INPUTSIZE * 2];
        inA.copyTo(arrayInA);
        long[] arrayInB = new long[INPUTSIZE * 2];
        inB.copyTo(arrayInB);
        long[] arrayOut = new long[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUlongUlongUlong args = new ArgumentsUlongUlongUlong();
                args.inA = arrayInA[i * 2 + j];
                args.inB = arrayInB[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("0x%x", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("0x%x", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("0x%x", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("0x%x", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUlong2Ulong2Ulong2" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxUlong3Ulong3Ulong3() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 3, 0xc28527c55b24be06l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 3, 0xc28527c55b24be07l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 3), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUlong3Ulong3Ulong3(inA, out);
            verifyResultsMaxUlong3Ulong3Ulong3(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUlong3Ulong3Ulong3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUlong3Ulong3Ulong3(inA, out);
            verifyResultsMaxUlong3Ulong3Ulong3(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUlong3Ulong3Ulong3: " + e.toString());
        }
    }

    private void verifyResultsMaxUlong3Ulong3Ulong3(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        long[] arrayInA = new long[INPUTSIZE * 4];
        inA.copyTo(arrayInA);
        long[] arrayInB = new long[INPUTSIZE * 4];
        inB.copyTo(arrayInB);
        long[] arrayOut = new long[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUlongUlongUlong args = new ArgumentsUlongUlongUlong();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("0x%x", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("0x%x", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("0x%x", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("0x%x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUlong3Ulong3Ulong3" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxUlong4Ulong4Ulong4() {
        Allocation inA = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 4, 0x16ea05e55d02bfa7l, false);
        Allocation inB = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 4, 0x16ea05e55d02bfa8l, false);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 4), INPUTSIZE);
            script.set_gAllocInB(inB);
            script.forEach_testMaxUlong4Ulong4Ulong4(inA, out);
            verifyResultsMaxUlong4Ulong4Ulong4(inA, inB, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUlong4Ulong4Ulong4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInB(inB);
            scriptRelaxed.forEach_testMaxUlong4Ulong4Ulong4(inA, out);
            verifyResultsMaxUlong4Ulong4Ulong4(inA, inB, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUlong4Ulong4Ulong4: " + e.toString());
        }
    }

    private void verifyResultsMaxUlong4Ulong4Ulong4(Allocation inA, Allocation inB, Allocation out, boolean relaxed) {
        long[] arrayInA = new long[INPUTSIZE * 4];
        inA.copyTo(arrayInA);
        long[] arrayInB = new long[INPUTSIZE * 4];
        inB.copyTo(arrayInB);
        long[] arrayOut = new long[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUlongUlongUlong args = new ArgumentsUlongUlongUlong();
                args.inA = arrayInA[i * 4 + j];
                args.inB = arrayInB[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append("Input inA: ");
                    message.append(String.format("0x%x", args.inA));
                    message.append("\n");
                    message.append("Input inB: ");
                    message.append(String.format("0x%x", args.inB));
                    message.append("\n");
                    message.append("Expected output out: ");
                    message.append(String.format("0x%x", args.out));
                    message.append("\n");
                    message.append("Actual   output out: ");
                    message.append(String.format("0x%x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUlong4Ulong4Ulong4" +
                            (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public void testMax() {
        checkMaxFloatFloatFloat();
        checkMaxFloat2Float2Float2();
        checkMaxFloat3Float3Float3();
        checkMaxFloat4Float4Float4();
        checkMaxCharCharChar();
        checkMaxChar2Char2Char2();
        checkMaxChar3Char3Char3();
        checkMaxChar4Char4Char4();
        checkMaxUcharUcharUchar();
        checkMaxUchar2Uchar2Uchar2();
        checkMaxUchar3Uchar3Uchar3();
        checkMaxUchar4Uchar4Uchar4();
        checkMaxShortShortShort();
        checkMaxShort2Short2Short2();
        checkMaxShort3Short3Short3();
        checkMaxShort4Short4Short4();
        checkMaxUshortUshortUshort();
        checkMaxUshort2Ushort2Ushort2();
        checkMaxUshort3Ushort3Ushort3();
        checkMaxUshort4Ushort4Ushort4();
        checkMaxIntIntInt();
        checkMaxInt2Int2Int2();
        checkMaxInt3Int3Int3();
        checkMaxInt4Int4Int4();
        checkMaxUintUintUint();
        checkMaxUint2Uint2Uint2();
        checkMaxUint3Uint3Uint3();
        checkMaxUint4Uint4Uint4();
        checkMaxLongLongLong();
        checkMaxLong2Long2Long2();
        checkMaxLong3Long3Long3();
        checkMaxLong4Long4Long4();
        checkMaxUlongUlongUlong();
        checkMaxUlong2Ulong2Ulong2();
        checkMaxUlong3Ulong3Ulong3();
        checkMaxUlong4Ulong4Ulong4();
    }
}
