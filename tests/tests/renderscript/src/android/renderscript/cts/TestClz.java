/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Don't edit this file!  It is auto-generated by frameworks/rs/api/gen_runtime.

package android.renderscript.cts;

import android.renderscript.Allocation;
import android.renderscript.RSRuntimeException;
import android.renderscript.Element;

public class TestClz extends RSBaseCompute {

    private ScriptC_TestClz script;
    private ScriptC_TestClzRelaxed scriptRelaxed;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        script = new ScriptC_TestClz(mRS);
        scriptRelaxed = new ScriptC_TestClzRelaxed(mRS);
    }

    public class ArgumentsCharChar {
        public byte inValue;
        public byte out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkClzCharChar() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0x4027c06bce499b9cL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 1), INPUTSIZE);
            script.forEach_testClzCharChar(inValue, out);
            verifyResultsClzCharChar(inValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzCharChar: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 1), INPUTSIZE);
            scriptRelaxed.forEach_testClzCharChar(inValue, out);
            verifyResultsClzCharChar(inValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzCharChar: " + e.toString());
        }
    }

    private void verifyResultsClzCharChar(Allocation inValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 1];
        inValue.copyTo(arrayInValue);
        byte[] arrayOut = new byte[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsCharChar args = new ArgumentsCharChar();
                args.inValue = arrayInValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClz(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClzCharChar" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClzChar2Char2() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 2, 0x5f1c0cd1b86413c0L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 2), INPUTSIZE);
            script.forEach_testClzChar2Char2(inValue, out);
            verifyResultsClzChar2Char2(inValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzChar2Char2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 2), INPUTSIZE);
            scriptRelaxed.forEach_testClzChar2Char2(inValue, out);
            verifyResultsClzChar2Char2(inValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzChar2Char2: " + e.toString());
        }
    }

    private void verifyResultsClzChar2Char2(Allocation inValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 2];
        inValue.copyTo(arrayInValue);
        byte[] arrayOut = new byte[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsCharChar args = new ArgumentsCharChar();
                args.inValue = arrayInValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClz(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClzChar2Char2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClzChar3Char3() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 3, 0x5f1c1773176bd8b4L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 3), INPUTSIZE);
            script.forEach_testClzChar3Char3(inValue, out);
            verifyResultsClzChar3Char3(inValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzChar3Char3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 3), INPUTSIZE);
            scriptRelaxed.forEach_testClzChar3Char3(inValue, out);
            verifyResultsClzChar3Char3(inValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzChar3Char3: " + e.toString());
        }
    }

    private void verifyResultsClzChar3Char3(Allocation inValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsCharChar args = new ArgumentsCharChar();
                args.inValue = arrayInValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClz(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClzChar3Char3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClzChar4Char4() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 4, 0x5f1c221476739da8L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 4), INPUTSIZE);
            script.forEach_testClzChar4Char4(inValue, out);
            verifyResultsClzChar4Char4(inValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzChar4Char4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 4), INPUTSIZE);
            scriptRelaxed.forEach_testClzChar4Char4(inValue, out);
            verifyResultsClzChar4Char4(inValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzChar4Char4: " + e.toString());
        }
    }

    private void verifyResultsClzChar4Char4(Allocation inValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsCharChar args = new ArgumentsCharChar();
                args.inValue = arrayInValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClz(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClzChar4Char4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsUcharUchar {
        public byte inValue;
        public byte out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkClzUcharUchar() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0x1e8a89bd939a7c6cL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 1), INPUTSIZE);
            script.forEach_testClzUcharUchar(inValue, out);
            verifyResultsClzUcharUchar(inValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzUcharUchar: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 1), INPUTSIZE);
            scriptRelaxed.forEach_testClzUcharUchar(inValue, out);
            verifyResultsClzUcharUchar(inValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzUcharUchar: " + e.toString());
        }
    }

    private void verifyResultsClzUcharUchar(Allocation inValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 1];
        inValue.copyTo(arrayInValue);
        byte[] arrayOut = new byte[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUchar args = new ArgumentsUcharUchar();
                args.inValue = arrayInValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClz(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClzUcharUchar" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClzUchar2Uchar2() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 2, 0x965dc58989efa952L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 2), INPUTSIZE);
            script.forEach_testClzUchar2Uchar2(inValue, out);
            verifyResultsClzUchar2Uchar2(inValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzUchar2Uchar2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 2), INPUTSIZE);
            scriptRelaxed.forEach_testClzUchar2Uchar2(inValue, out);
            verifyResultsClzUchar2Uchar2(inValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzUchar2Uchar2: " + e.toString());
        }
    }

    private void verifyResultsClzUchar2Uchar2(Allocation inValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 2];
        inValue.copyTo(arrayInValue);
        byte[] arrayOut = new byte[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUchar args = new ArgumentsUcharUchar();
                args.inValue = arrayInValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClz(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClzUchar2Uchar2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClzUchar3Uchar3() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 3, 0x965f8ea4800aca30L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 3), INPUTSIZE);
            script.forEach_testClzUchar3Uchar3(inValue, out);
            verifyResultsClzUchar3Uchar3(inValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzUchar3Uchar3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 3), INPUTSIZE);
            scriptRelaxed.forEach_testClzUchar3Uchar3(inValue, out);
            verifyResultsClzUchar3Uchar3(inValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzUchar3Uchar3: " + e.toString());
        }
    }

    private void verifyResultsClzUchar3Uchar3(Allocation inValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUchar args = new ArgumentsUcharUchar();
                args.inValue = arrayInValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClz(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClzUchar3Uchar3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClzUchar4Uchar4() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 4, 0x966157bf7625eb0eL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 4), INPUTSIZE);
            script.forEach_testClzUchar4Uchar4(inValue, out);
            verifyResultsClzUchar4Uchar4(inValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzUchar4Uchar4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 4), INPUTSIZE);
            scriptRelaxed.forEach_testClzUchar4Uchar4(inValue, out);
            verifyResultsClzUchar4Uchar4(inValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzUchar4Uchar4: " + e.toString());
        }
    }

    private void verifyResultsClzUchar4Uchar4(Allocation inValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUchar args = new ArgumentsUcharUchar();
                args.inValue = arrayInValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClz(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClzUchar4Uchar4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsShortShort {
        public short inValue;
        public short out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkClzShortShort() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0xc23bfb32ff57e80L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 1), INPUTSIZE);
            script.forEach_testClzShortShort(inValue, out);
            verifyResultsClzShortShort(inValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzShortShort: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 1), INPUTSIZE);
            scriptRelaxed.forEach_testClzShortShort(inValue, out);
            verifyResultsClzShortShort(inValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzShortShort: " + e.toString());
        }
    }

    private void verifyResultsClzShortShort(Allocation inValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 1];
        inValue.copyTo(arrayInValue);
        short[] arrayOut = new short[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsShortShort args = new ArgumentsShortShort();
                args.inValue = arrayInValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClz(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClzShortShort" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClzShort2Short2() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 2, 0xadf7c7bf62fe59acL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 2), INPUTSIZE);
            script.forEach_testClzShort2Short2(inValue, out);
            verifyResultsClzShort2Short2(inValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzShort2Short2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 2), INPUTSIZE);
            scriptRelaxed.forEach_testClzShort2Short2(inValue, out);
            verifyResultsClzShort2Short2(inValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzShort2Short2: " + e.toString());
        }
    }

    private void verifyResultsClzShort2Short2(Allocation inValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 2];
        inValue.copyTo(arrayInValue);
        short[] arrayOut = new short[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsShortShort args = new ArgumentsShortShort();
                args.inValue = arrayInValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClz(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClzShort2Short2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClzShort3Short3() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 3, 0xadf990da59197a8aL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 3), INPUTSIZE);
            script.forEach_testClzShort3Short3(inValue, out);
            verifyResultsClzShort3Short3(inValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzShort3Short3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 3), INPUTSIZE);
            scriptRelaxed.forEach_testClzShort3Short3(inValue, out);
            verifyResultsClzShort3Short3(inValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzShort3Short3: " + e.toString());
        }
    }

    private void verifyResultsClzShort3Short3(Allocation inValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsShortShort args = new ArgumentsShortShort();
                args.inValue = arrayInValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClz(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClzShort3Short3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClzShort4Short4() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 4, 0xadfb59f54f349b68L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 4), INPUTSIZE);
            script.forEach_testClzShort4Short4(inValue, out);
            verifyResultsClzShort4Short4(inValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzShort4Short4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 4), INPUTSIZE);
            scriptRelaxed.forEach_testClzShort4Short4(inValue, out);
            verifyResultsClzShort4Short4(inValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzShort4Short4: " + e.toString());
        }
    }

    private void verifyResultsClzShort4Short4(Allocation inValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsShortShort args = new ArgumentsShortShort();
                args.inValue = arrayInValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClz(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClzShort4Short4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsUshortUshort {
        public short inValue;
        public short out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkClzUshortUshort() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0xa6a82b331bf5ea72L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 1), INPUTSIZE);
            script.forEach_testClzUshortUshort(inValue, out);
            verifyResultsClzUshortUshort(inValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzUshortUshort: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 1), INPUTSIZE);
            scriptRelaxed.forEach_testClzUshortUshort(inValue, out);
            verifyResultsClzUshortUshort(inValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzUshortUshort: " + e.toString());
        }
    }

    private void verifyResultsClzUshortUshort(Allocation inValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 1];
        inValue.copyTo(arrayInValue);
        short[] arrayOut = new short[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshort args = new ArgumentsUshortUshort();
                args.inValue = arrayInValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClz(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClzUshortUshort" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClzUshort2Ushort2() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 2, 0xa9eb9eaae6cf28a4L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 2), INPUTSIZE);
            script.forEach_testClzUshort2Ushort2(inValue, out);
            verifyResultsClzUshort2Ushort2(inValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzUshort2Ushort2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 2), INPUTSIZE);
            scriptRelaxed.forEach_testClzUshort2Ushort2(inValue, out);
            verifyResultsClzUshort2Ushort2(inValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzUshort2Ushort2: " + e.toString());
        }
    }

    private void verifyResultsClzUshort2Ushort2(Allocation inValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 2];
        inValue.copyTo(arrayInValue);
        short[] arrayOut = new short[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshort args = new ArgumentsUshortUshort();
                args.inValue = arrayInValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClz(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClzUshort2Ushort2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClzUshort3Ushort3() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 3, 0xaa3866323d2ab9d0L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 3), INPUTSIZE);
            script.forEach_testClzUshort3Ushort3(inValue, out);
            verifyResultsClzUshort3Ushort3(inValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzUshort3Ushort3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 3), INPUTSIZE);
            scriptRelaxed.forEach_testClzUshort3Ushort3(inValue, out);
            verifyResultsClzUshort3Ushort3(inValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzUshort3Ushort3: " + e.toString());
        }
    }

    private void verifyResultsClzUshort3Ushort3(Allocation inValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshort args = new ArgumentsUshortUshort();
                args.inValue = arrayInValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClz(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClzUshort3Ushort3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClzUshort4Ushort4() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 4, 0xaa852db993864afcL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 4), INPUTSIZE);
            script.forEach_testClzUshort4Ushort4(inValue, out);
            verifyResultsClzUshort4Ushort4(inValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzUshort4Ushort4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 4), INPUTSIZE);
            scriptRelaxed.forEach_testClzUshort4Ushort4(inValue, out);
            verifyResultsClzUshort4Ushort4(inValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzUshort4Ushort4: " + e.toString());
        }
    }

    private void verifyResultsClzUshort4Ushort4(Allocation inValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshort args = new ArgumentsUshortUshort();
                args.inValue = arrayInValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClz(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClzUshort4Ushort4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsIntInt {
        public int inValue;
        public int out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkClzIntInt() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0x136b4d1a7cf62a04L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 1), INPUTSIZE);
            script.forEach_testClzIntInt(inValue, out);
            verifyResultsClzIntInt(inValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzIntInt: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 1), INPUTSIZE);
            scriptRelaxed.forEach_testClzIntInt(inValue, out);
            verifyResultsClzIntInt(inValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzIntInt: " + e.toString());
        }
    }

    private void verifyResultsClzIntInt(Allocation inValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 1];
        inValue.copyTo(arrayInValue);
        int[] arrayOut = new int[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsIntInt args = new ArgumentsIntInt();
                args.inValue = arrayInValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClz(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClzIntInt" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClzInt2Int2() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 2, 0x41ffde6a49a000a2L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 2), INPUTSIZE);
            script.forEach_testClzInt2Int2(inValue, out);
            verifyResultsClzInt2Int2(inValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzInt2Int2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 2), INPUTSIZE);
            scriptRelaxed.forEach_testClzInt2Int2(inValue, out);
            verifyResultsClzInt2Int2(inValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzInt2Int2: " + e.toString());
        }
    }

    private void verifyResultsClzInt2Int2(Allocation inValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 2];
        inValue.copyTo(arrayInValue);
        int[] arrayOut = new int[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsIntInt args = new ArgumentsIntInt();
                args.inValue = arrayInValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClz(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClzInt2Int2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClzInt3Int3() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 3, 0x41ffdea9934810d8L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 3), INPUTSIZE);
            script.forEach_testClzInt3Int3(inValue, out);
            verifyResultsClzInt3Int3(inValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzInt3Int3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 3), INPUTSIZE);
            scriptRelaxed.forEach_testClzInt3Int3(inValue, out);
            verifyResultsClzInt3Int3(inValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzInt3Int3: " + e.toString());
        }
    }

    private void verifyResultsClzInt3Int3(Allocation inValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsIntInt args = new ArgumentsIntInt();
                args.inValue = arrayInValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClz(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClzInt3Int3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClzInt4Int4() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 4, 0x41ffdee8dcf0210eL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 4), INPUTSIZE);
            script.forEach_testClzInt4Int4(inValue, out);
            verifyResultsClzInt4Int4(inValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzInt4Int4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 4), INPUTSIZE);
            scriptRelaxed.forEach_testClzInt4Int4(inValue, out);
            verifyResultsClzInt4Int4(inValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzInt4Int4: " + e.toString());
        }
    }

    private void verifyResultsClzInt4Int4(Allocation inValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsIntInt args = new ArgumentsIntInt();
                args.inValue = arrayInValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClz(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %d", args.inValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClzInt4Int4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsUintUint {
        public int inValue;
        public int out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkClzUintUint() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0x45901bd5c6e2ce1cL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 1), INPUTSIZE);
            script.forEach_testClzUintUint(inValue, out);
            verifyResultsClzUintUint(inValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzUintUint: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 1), INPUTSIZE);
            scriptRelaxed.forEach_testClzUintUint(inValue, out);
            verifyResultsClzUintUint(inValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzUintUint: " + e.toString());
        }
    }

    private void verifyResultsClzUintUint(Allocation inValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 1];
        inValue.copyTo(arrayInValue);
        int[] arrayOut = new int[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUintUint args = new ArgumentsUintUint();
                args.inValue = arrayInValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClz(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClzUintUint" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClzUint2Uint2() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 2, 0x6dd792002fe754c0L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 2), INPUTSIZE);
            script.forEach_testClzUint2Uint2(inValue, out);
            verifyResultsClzUint2Uint2(inValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzUint2Uint2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 2), INPUTSIZE);
            scriptRelaxed.forEach_testClzUint2Uint2(inValue, out);
            verifyResultsClzUint2Uint2(inValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzUint2Uint2: " + e.toString());
        }
    }

    private void verifyResultsClzUint2Uint2(Allocation inValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 2];
        inValue.copyTo(arrayInValue);
        int[] arrayOut = new int[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUintUint args = new ArgumentsUintUint();
                args.inValue = arrayInValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClz(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClzUint2Uint2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClzUint3Uint3() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 3, 0x6dd79ca18eef19b4L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 3), INPUTSIZE);
            script.forEach_testClzUint3Uint3(inValue, out);
            verifyResultsClzUint3Uint3(inValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzUint3Uint3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 3), INPUTSIZE);
            scriptRelaxed.forEach_testClzUint3Uint3(inValue, out);
            verifyResultsClzUint3Uint3(inValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzUint3Uint3: " + e.toString());
        }
    }

    private void verifyResultsClzUint3Uint3(Allocation inValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUintUint args = new ArgumentsUintUint();
                args.inValue = arrayInValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClz(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClzUint3Uint3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkClzUint4Uint4() {
        Allocation inValue = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 4, 0x6dd7a742edf6dea8L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 4), INPUTSIZE);
            script.forEach_testClzUint4Uint4(inValue, out);
            verifyResultsClzUint4Uint4(inValue, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzUint4Uint4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 4), INPUTSIZE);
            scriptRelaxed.forEach_testClzUint4Uint4(inValue, out);
            verifyResultsClzUint4Uint4(inValue, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClzUint4Uint4: " + e.toString());
        }
    }

    private void verifyResultsClzUint4Uint4(Allocation inValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        inValue.copyTo(arrayInValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUintUint args = new ArgumentsUintUint();
                args.inValue = arrayInValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClz(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inValue: %x", args.inValue));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkClzUint4Uint4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public void testClz() {
        checkClzCharChar();
        checkClzChar2Char2();
        checkClzChar3Char3();
        checkClzChar4Char4();
        checkClzUcharUchar();
        checkClzUchar2Uchar2();
        checkClzUchar3Uchar3();
        checkClzUchar4Uchar4();
        checkClzShortShort();
        checkClzShort2Short2();
        checkClzShort3Short3();
        checkClzShort4Short4();
        checkClzUshortUshort();
        checkClzUshort2Ushort2();
        checkClzUshort3Ushort3();
        checkClzUshort4Ushort4();
        checkClzIntInt();
        checkClzInt2Int2();
        checkClzInt3Int3();
        checkClzInt4Int4();
        checkClzUintUint();
        checkClzUint2Uint2();
        checkClzUint3Uint3();
        checkClzUint4Uint4();
    }
}
