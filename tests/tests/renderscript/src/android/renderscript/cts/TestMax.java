/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Don't edit this file!  It is auto-generated by frameworks/rs/api/gen_runtime.

package android.renderscript.cts;

import android.renderscript.Allocation;
import android.renderscript.RSRuntimeException;
import android.renderscript.Element;

public class TestMax extends RSBaseCompute {

    private ScriptC_TestMax script;
    private ScriptC_TestMaxRelaxed scriptRelaxed;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        script = new ScriptC_TestMax(mRS);
        scriptRelaxed = new ScriptC_TestMaxRelaxed(mRS);
    }

    public class ArgumentsFloatFloatFloat {
        public float in;
        public float in1;
        public float out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkMaxFloatFloatFloat() {
        Allocation in = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0x2952d868c2163f4cL);
        Allocation in1 = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0x2952d868c2163f4cL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 1), INPUTSIZE);
            script.set_gAllocIn1(in1);
            script.forEach_testMaxFloatFloatFloat(in, out);
            verifyResultsMaxFloatFloatFloat(in, in1, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloatFloatFloat: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocIn1(in1);
            scriptRelaxed.forEach_testMaxFloatFloatFloat(in, out);
            verifyResultsMaxFloatFloatFloat(in, in1, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloatFloatFloat: " + e.toString());
        }
    }

    private void verifyResultsMaxFloatFloatFloat(Allocation in, Allocation in1, Allocation out, boolean relaxed) {
        float[] arrayIn = new float[INPUTSIZE * 1];
        in.copyTo(arrayIn);
        float[] arrayIn1 = new float[INPUTSIZE * 1];
        in1.copyTo(arrayIn1);
        float[] arrayOut = new float[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloat args = new ArgumentsFloatFloatFloat();
                args.in = arrayIn[i];
                args.in1 = arrayIn1[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                neededUlf = (int) (Math.abs(args.out - arrayOut[i * 1 + j]) / Math.ulp(args.out) + 0.5);
                if (neededUlf > ulf) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input in: %x %.16f", Float.floatToRawIntBits(args.in), args.in));
                    message.append("\n");
                    message.append(String.format("Input in1: %x %.16f", Float.floatToRawIntBits(args.in1), args.in1));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x %.16f", Float.floatToRawIntBits(args.out), args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x %.16f", Float.floatToRawIntBits(arrayOut[i * 1 + j]), arrayOut[i * 1 + j]));
                    neededUlf = (int) (Math.abs(args.out - arrayOut[i * 1 + j]) / Math.ulp(args.out) + 0.5);
                    if (neededUlf > ulf) {
                        message.append(String.format(" FAILED, ulf needed %d, specified %d", neededUlf, ulf));
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxFloatFloatFloat" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxFloat2Float2Float2() {
        Allocation in = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 2, 0xc6031e7536adf5c6L);
        Allocation in1 = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 2, 0xc6031e7536adf5c6L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 2), INPUTSIZE);
            script.set_gAllocIn1(in1);
            script.forEach_testMaxFloat2Float2Float2(in, out);
            verifyResultsMaxFloat2Float2Float2(in, in1, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloat2Float2Float2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocIn1(in1);
            scriptRelaxed.forEach_testMaxFloat2Float2Float2(in, out);
            verifyResultsMaxFloat2Float2Float2(in, in1, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloat2Float2Float2: " + e.toString());
        }
    }

    private void verifyResultsMaxFloat2Float2Float2(Allocation in, Allocation in1, Allocation out, boolean relaxed) {
        float[] arrayIn = new float[INPUTSIZE * 2];
        in.copyTo(arrayIn);
        float[] arrayIn1 = new float[INPUTSIZE * 2];
        in1.copyTo(arrayIn1);
        float[] arrayOut = new float[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloat args = new ArgumentsFloatFloatFloat();
                args.in = arrayIn[i * 2 + j];
                args.in1 = arrayIn1[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                neededUlf = (int) (Math.abs(args.out - arrayOut[i * 2 + j]) / Math.ulp(args.out) + 0.5);
                if (neededUlf > ulf) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input in: %x %.16f", Float.floatToRawIntBits(args.in), args.in));
                    message.append("\n");
                    message.append(String.format("Input in1: %x %.16f", Float.floatToRawIntBits(args.in1), args.in1));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x %.16f", Float.floatToRawIntBits(args.out), args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x %.16f", Float.floatToRawIntBits(arrayOut[i * 2 + j]), arrayOut[i * 2 + j]));
                    neededUlf = (int) (Math.abs(args.out - arrayOut[i * 2 + j]) / Math.ulp(args.out) + 0.5);
                    if (neededUlf > ulf) {
                        message.append(String.format(" FAILED, ulf needed %d, specified %d", neededUlf, ulf));
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxFloat2Float2Float2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxFloat3Float3Float3() {
        Allocation in = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 3, 0x1a67fc95388bf767L);
        Allocation in1 = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 3, 0x1a67fc95388bf767L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 3), INPUTSIZE);
            script.set_gAllocIn1(in1);
            script.forEach_testMaxFloat3Float3Float3(in, out);
            verifyResultsMaxFloat3Float3Float3(in, in1, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloat3Float3Float3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocIn1(in1);
            scriptRelaxed.forEach_testMaxFloat3Float3Float3(in, out);
            verifyResultsMaxFloat3Float3Float3(in, in1, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloat3Float3Float3: " + e.toString());
        }
    }

    private void verifyResultsMaxFloat3Float3Float3(Allocation in, Allocation in1, Allocation out, boolean relaxed) {
        float[] arrayIn = new float[INPUTSIZE * 4];
        in.copyTo(arrayIn);
        float[] arrayIn1 = new float[INPUTSIZE * 4];
        in1.copyTo(arrayIn1);
        float[] arrayOut = new float[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloat args = new ArgumentsFloatFloatFloat();
                args.in = arrayIn[i * 4 + j];
                args.in1 = arrayIn1[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                neededUlf = (int) (Math.abs(args.out - arrayOut[i * 4 + j]) / Math.ulp(args.out) + 0.5);
                if (neededUlf > ulf) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input in: %x %.16f", Float.floatToRawIntBits(args.in), args.in));
                    message.append("\n");
                    message.append(String.format("Input in1: %x %.16f", Float.floatToRawIntBits(args.in1), args.in1));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x %.16f", Float.floatToRawIntBits(args.out), args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x %.16f", Float.floatToRawIntBits(arrayOut[i * 4 + j]), arrayOut[i * 4 + j]));
                    neededUlf = (int) (Math.abs(args.out - arrayOut[i * 4 + j]) / Math.ulp(args.out) + 0.5);
                    if (neededUlf > ulf) {
                        message.append(String.format(" FAILED, ulf needed %d, specified %d", neededUlf, ulf));
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxFloat3Float3Float3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxFloat4Float4Float4() {
        Allocation in = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 4, 0x6eccdab53a69f908L);
        Allocation in1 = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 4, 0x6eccdab53a69f908L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 4), INPUTSIZE);
            script.set_gAllocIn1(in1);
            script.forEach_testMaxFloat4Float4Float4(in, out);
            verifyResultsMaxFloat4Float4Float4(in, in1, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloat4Float4Float4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocIn1(in1);
            scriptRelaxed.forEach_testMaxFloat4Float4Float4(in, out);
            verifyResultsMaxFloat4Float4Float4(in, in1, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxFloat4Float4Float4: " + e.toString());
        }
    }

    private void verifyResultsMaxFloat4Float4Float4(Allocation in, Allocation in1, Allocation out, boolean relaxed) {
        float[] arrayIn = new float[INPUTSIZE * 4];
        in.copyTo(arrayIn);
        float[] arrayIn1 = new float[INPUTSIZE * 4];
        in1.copyTo(arrayIn1);
        float[] arrayOut = new float[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloat args = new ArgumentsFloatFloatFloat();
                args.in = arrayIn[i * 4 + j];
                args.in1 = arrayIn1[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                neededUlf = (int) (Math.abs(args.out - arrayOut[i * 4 + j]) / Math.ulp(args.out) + 0.5);
                if (neededUlf > ulf) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input in: %x %.16f", Float.floatToRawIntBits(args.in), args.in));
                    message.append("\n");
                    message.append(String.format("Input in1: %x %.16f", Float.floatToRawIntBits(args.in1), args.in1));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x %.16f", Float.floatToRawIntBits(args.out), args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x %.16f", Float.floatToRawIntBits(arrayOut[i * 4 + j]), arrayOut[i * 4 + j]));
                    neededUlf = (int) (Math.abs(args.out - arrayOut[i * 4 + j]) / Math.ulp(args.out) + 0.5);
                    if (neededUlf > ulf) {
                        message.append(String.format(" FAILED, ulf needed %d, specified %d", neededUlf, ulf));
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxFloat4Float4Float4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsCharCharChar {
        public byte inV1;
        public byte inV2;
        public byte out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkMaxCharCharChar() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0x5f77cf3cb6407362L);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0x5f77cf3cb6407362L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 1), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMaxCharCharChar(inV1, out);
            verifyResultsMaxCharCharChar(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxCharCharChar: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMaxCharCharChar(inV1, out);
            verifyResultsMaxCharCharChar(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxCharCharChar: " + e.toString());
        }
    }

    private void verifyResultsMaxCharCharChar(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        byte[] arrayInV1 = new byte[INPUTSIZE * 1];
        inV1.copyTo(arrayInV1);
        byte[] arrayInV2 = new byte[INPUTSIZE * 1];
        inV2.copyTo(arrayInV2);
        byte[] arrayOut = new byte[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharChar args = new ArgumentsCharCharChar();
                args.inV1 = arrayInV1[i];
                args.inV2 = arrayInV2[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %d", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %d", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxCharCharChar" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsUcharUcharUchar {
        public byte inV1;
        public byte inV2;
        public byte out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkMaxUcharUcharUchar() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0x800f9948853a3119L);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0x800f9948853a3119L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 1), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMaxUcharUcharUchar(inV1, out);
            verifyResultsMaxUcharUcharUchar(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUcharUcharUchar: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMaxUcharUcharUchar(inV1, out);
            verifyResultsMaxUcharUcharUchar(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUcharUcharUchar: " + e.toString());
        }
    }

    private void verifyResultsMaxUcharUcharUchar(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        byte[] arrayInV1 = new byte[INPUTSIZE * 1];
        inV1.copyTo(arrayInV1);
        byte[] arrayInV2 = new byte[INPUTSIZE * 1];
        inV2.copyTo(arrayInV2);
        byte[] arrayOut = new byte[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUchar args = new ArgumentsUcharUcharUchar();
                args.inV1 = arrayInV1[i];
                args.inV2 = arrayInV2[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %x", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %x", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUcharUcharUchar" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsShortShortShort {
        public short inV1;
        public short inV2;
        public short out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkMaxShortShortShort() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0x920335e143b58d80L);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0x920335e143b58d80L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 1), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMaxShortShortShort(inV1, out);
            verifyResultsMaxShortShortShort(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxShortShortShort: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMaxShortShortShort(inV1, out);
            verifyResultsMaxShortShortShort(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxShortShortShort: " + e.toString());
        }
    }

    private void verifyResultsMaxShortShortShort(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        short[] arrayInV1 = new short[INPUTSIZE * 1];
        inV1.copyTo(arrayInV1);
        short[] arrayInV2 = new short[INPUTSIZE * 1];
        inV2.copyTo(arrayInV2);
        short[] arrayOut = new short[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShort args = new ArgumentsShortShortShort();
                args.inV1 = arrayInV1[i];
                args.inV2 = arrayInV2[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %d", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %d", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxShortShortShort" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsUshortUshortUshort {
        public short inV1;
        public short inV2;
        public short out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkMaxUshortUshortUshort() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0x8f869c73b9478b37L);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0x8f869c73b9478b37L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 1), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMaxUshortUshortUshort(inV1, out);
            verifyResultsMaxUshortUshortUshort(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUshortUshortUshort: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMaxUshortUshortUshort(inV1, out);
            verifyResultsMaxUshortUshortUshort(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUshortUshortUshort: " + e.toString());
        }
    }

    private void verifyResultsMaxUshortUshortUshort(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        short[] arrayInV1 = new short[INPUTSIZE * 1];
        inV1.copyTo(arrayInV1);
        short[] arrayInV2 = new short[INPUTSIZE * 1];
        inV2.copyTo(arrayInV2);
        short[] arrayOut = new short[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshort args = new ArgumentsUshortUshortUshort();
                args.inV1 = arrayInV1[i];
                args.inV2 = arrayInV2[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %x", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %x", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUshortUshortUshort" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsIntIntInt {
        public int inV1;
        public int inV2;
        public int out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkMaxIntIntInt() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0x773d0d60e43d2a95L);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0x773d0d60e43d2a95L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 1), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMaxIntIntInt(inV1, out);
            verifyResultsMaxIntIntInt(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxIntIntInt: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMaxIntIntInt(inV1, out);
            verifyResultsMaxIntIntInt(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxIntIntInt: " + e.toString());
        }
    }

    private void verifyResultsMaxIntIntInt(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        int[] arrayInV1 = new int[INPUTSIZE * 1];
        inV1.copyTo(arrayInV1);
        int[] arrayInV2 = new int[INPUTSIZE * 1];
        inV2.copyTo(arrayInV2);
        int[] arrayOut = new int[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntInt args = new ArgumentsIntIntInt();
                args.inV1 = arrayInV1[i];
                args.inV2 = arrayInV2[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %d", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %d", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxIntIntInt" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsUintUintUint {
        public int inV1;
        public int inV2;
        public int out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkMaxUintUintUint() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0xcd24e58385f75922L);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0xcd24e58385f75922L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 1), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMaxUintUintUint(inV1, out);
            verifyResultsMaxUintUintUint(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUintUintUint: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMaxUintUintUint(inV1, out);
            verifyResultsMaxUintUintUint(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUintUintUint: " + e.toString());
        }
    }

    private void verifyResultsMaxUintUintUint(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        int[] arrayInV1 = new int[INPUTSIZE * 1];
        inV1.copyTo(arrayInV1);
        int[] arrayInV2 = new int[INPUTSIZE * 1];
        inV2.copyTo(arrayInV2);
        int[] arrayOut = new int[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUint args = new ArgumentsUintUintUint();
                args.inV1 = arrayInV1[i];
                args.inV2 = arrayInV2[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %x", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %x", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUintUintUint" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxChar2Char2Char2() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 2, 0x94dd090a19e442f0L);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 2, 0x94dd090a19e442f0L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 2), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMaxChar2Char2Char2(inV1, out);
            verifyResultsMaxChar2Char2Char2(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxChar2Char2Char2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMaxChar2Char2Char2(inV1, out);
            verifyResultsMaxChar2Char2Char2(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxChar2Char2Char2: " + e.toString());
        }
    }

    private void verifyResultsMaxChar2Char2Char2(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        byte[] arrayInV1 = new byte[INPUTSIZE * 2];
        inV1.copyTo(arrayInV1);
        byte[] arrayInV2 = new byte[INPUTSIZE * 2];
        inV2.copyTo(arrayInV2);
        byte[] arrayOut = new byte[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharChar args = new ArgumentsCharCharChar();
                args.inV1 = arrayInV1[i * 2 + j];
                args.inV2 = arrayInV2[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %d", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %d", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxChar2Char2Char2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxUchar2Uchar2Uchar2() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 2, 0xd31d5735b7e9c4c7L);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 2, 0xd31d5735b7e9c4c7L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 2), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMaxUchar2Uchar2Uchar2(inV1, out);
            verifyResultsMaxUchar2Uchar2Uchar2(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUchar2Uchar2Uchar2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMaxUchar2Uchar2Uchar2(inV1, out);
            verifyResultsMaxUchar2Uchar2Uchar2(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUchar2Uchar2Uchar2: " + e.toString());
        }
    }

    private void verifyResultsMaxUchar2Uchar2Uchar2(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        byte[] arrayInV1 = new byte[INPUTSIZE * 2];
        inV1.copyTo(arrayInV1);
        byte[] arrayInV2 = new byte[INPUTSIZE * 2];
        inV2.copyTo(arrayInV2);
        byte[] arrayOut = new byte[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUchar args = new ArgumentsUcharUcharUchar();
                args.inV1 = arrayInV1[i * 2 + j];
                args.inV2 = arrayInV2[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %x", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %x", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUchar2Uchar2Uchar2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxShort2Short2Short2() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 2, 0x42e9d46b56ecd4caL);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 2, 0x42e9d46b56ecd4caL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 2), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMaxShort2Short2Short2(inV1, out);
            verifyResultsMaxShort2Short2Short2(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxShort2Short2Short2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMaxShort2Short2Short2(inV1, out);
            verifyResultsMaxShort2Short2Short2(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxShort2Short2Short2: " + e.toString());
        }
    }

    private void verifyResultsMaxShort2Short2Short2(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        short[] arrayInV1 = new short[INPUTSIZE * 2];
        inV1.copyTo(arrayInV1);
        short[] arrayInV2 = new short[INPUTSIZE * 2];
        inV2.copyTo(arrayInV2);
        short[] arrayOut = new short[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShort args = new ArgumentsShortShortShort();
                args.inV1 = arrayInV1[i * 2 + j];
                args.inV2 = arrayInV2[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %d", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %d", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxShort2Short2Short2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxUshort2Ushort2Ushort2() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 2, 0xbe3c50e6150b3a81L);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 2, 0xbe3c50e6150b3a81L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 2), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMaxUshort2Ushort2Ushort2(inV1, out);
            verifyResultsMaxUshort2Ushort2Ushort2(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUshort2Ushort2Ushort2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMaxUshort2Ushort2Ushort2(inV1, out);
            verifyResultsMaxUshort2Ushort2Ushort2(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUshort2Ushort2Ushort2: " + e.toString());
        }
    }

    private void verifyResultsMaxUshort2Ushort2Ushort2(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        short[] arrayInV1 = new short[INPUTSIZE * 2];
        inV1.copyTo(arrayInV1);
        short[] arrayInV2 = new short[INPUTSIZE * 2];
        inV2.copyTo(arrayInV2);
        short[] arrayOut = new short[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshort args = new ArgumentsUshortUshortUshort();
                args.inV1 = arrayInV1[i * 2 + j];
                args.inV2 = arrayInV2[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %x", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %x", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUshort2Ushort2Ushort2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxInt2Int2Int2() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 2, 0x32815a01bb9de7c3L);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 2, 0x32815a01bb9de7c3L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 2), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMaxInt2Int2Int2(inV1, out);
            verifyResultsMaxInt2Int2Int2(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxInt2Int2Int2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMaxInt2Int2Int2(inV1, out);
            verifyResultsMaxInt2Int2Int2(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxInt2Int2Int2: " + e.toString());
        }
    }

    private void verifyResultsMaxInt2Int2Int2(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        int[] arrayInV1 = new int[INPUTSIZE * 2];
        inV1.copyTo(arrayInV1);
        int[] arrayInV2 = new int[INPUTSIZE * 2];
        inV2.copyTo(arrayInV2);
        int[] arrayOut = new int[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntInt args = new ArgumentsIntIntInt();
                args.inV1 = arrayInV1[i * 2 + j];
                args.inV2 = arrayInV2[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %d", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %d", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxInt2Int2Int2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxUint2Uint2Uint2() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 2, 0xbd5747860e84f1b0L);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 2, 0xbd5747860e84f1b0L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 2), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMaxUint2Uint2Uint2(inV1, out);
            verifyResultsMaxUint2Uint2Uint2(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUint2Uint2Uint2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMaxUint2Uint2Uint2(inV1, out);
            verifyResultsMaxUint2Uint2Uint2(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUint2Uint2Uint2: " + e.toString());
        }
    }

    private void verifyResultsMaxUint2Uint2Uint2(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        int[] arrayInV1 = new int[INPUTSIZE * 2];
        inV1.copyTo(arrayInV1);
        int[] arrayInV2 = new int[INPUTSIZE * 2];
        inV2.copyTo(arrayInV2);
        int[] arrayOut = new int[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUint args = new ArgumentsUintUintUint();
                args.inV1 = arrayInV1[i * 2 + j];
                args.inV2 = arrayInV2[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %x", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %x", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUint2Uint2Uint2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxChar3Char3Char3() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 3, 0xba9188f3788353bfL);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 3, 0xba9188f3788353bfL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 3), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMaxChar3Char3Char3(inV1, out);
            verifyResultsMaxChar3Char3Char3(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxChar3Char3Char3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMaxChar3Char3Char3(inV1, out);
            verifyResultsMaxChar3Char3Char3(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxChar3Char3Char3: " + e.toString());
        }
    }

    private void verifyResultsMaxChar3Char3Char3(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        byte[] arrayInV1 = new byte[INPUTSIZE * 4];
        inV1.copyTo(arrayInV1);
        byte[] arrayInV2 = new byte[INPUTSIZE * 4];
        inV2.copyTo(arrayInV2);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharChar args = new ArgumentsCharCharChar();
                args.inV1 = arrayInV1[i * 4 + j];
                args.inV2 = arrayInV2[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %d", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %d", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxChar3Char3Char3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxUchar3Uchar3Uchar3() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 3, 0x27823555b9c7c668L);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 3, 0x27823555b9c7c668L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 3), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMaxUchar3Uchar3Uchar3(inV1, out);
            verifyResultsMaxUchar3Uchar3Uchar3(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUchar3Uchar3Uchar3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMaxUchar3Uchar3Uchar3(inV1, out);
            verifyResultsMaxUchar3Uchar3Uchar3(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUchar3Uchar3Uchar3: " + e.toString());
        }
    }

    private void verifyResultsMaxUchar3Uchar3Uchar3(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        byte[] arrayInV1 = new byte[INPUTSIZE * 4];
        inV1.copyTo(arrayInV1);
        byte[] arrayInV2 = new byte[INPUTSIZE * 4];
        inV2.copyTo(arrayInV2);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUchar args = new ArgumentsUcharUcharUchar();
                args.inV1 = arrayInV1[i * 4 + j];
                args.inV2 = arrayInV2[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %x", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %x", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUchar3Uchar3Uchar3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxShort3Short3Short3() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 3, 0x974eb28b58cad66bL);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 3, 0x974eb28b58cad66bL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 3), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMaxShort3Short3Short3(inV1, out);
            verifyResultsMaxShort3Short3Short3(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxShort3Short3Short3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMaxShort3Short3Short3(inV1, out);
            verifyResultsMaxShort3Short3Short3(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxShort3Short3Short3: " + e.toString());
        }
    }

    private void verifyResultsMaxShort3Short3Short3(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        short[] arrayInV1 = new short[INPUTSIZE * 4];
        inV1.copyTo(arrayInV1);
        short[] arrayInV2 = new short[INPUTSIZE * 4];
        inV2.copyTo(arrayInV2);
        short[] arrayOut = new short[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShort args = new ArgumentsShortShortShort();
                args.inV1 = arrayInV1[i * 4 + j];
                args.inV2 = arrayInV2[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %d", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %d", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxShort3Short3Short3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxUshort3Ushort3Ushort3() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 3, 0x3e2be9df5df02c18L);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 3, 0x3e2be9df5df02c18L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 3), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMaxUshort3Ushort3Ushort3(inV1, out);
            verifyResultsMaxUshort3Ushort3Ushort3(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUshort3Ushort3Ushort3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMaxUshort3Ushort3Ushort3(inV1, out);
            verifyResultsMaxUshort3Ushort3Ushort3(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUshort3Ushort3Ushort3: " + e.toString());
        }
    }

    private void verifyResultsMaxUshort3Ushort3Ushort3(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        short[] arrayInV1 = new short[INPUTSIZE * 4];
        inV1.copyTo(arrayInV1);
        short[] arrayInV2 = new short[INPUTSIZE * 4];
        inV2.copyTo(arrayInV2);
        short[] arrayOut = new short[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshort args = new ArgumentsUshortUshortUshort();
                args.inV1 = arrayInV1[i * 4 + j];
                args.inV2 = arrayInV2[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %x", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %x", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUshort3Ushort3Ushort3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxInt3Int3Int3() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 3, 0x3f66ddfc86732facL);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 3, 0x3f66ddfc86732facL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 3), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMaxInt3Int3Int3(inV1, out);
            verifyResultsMaxInt3Int3Int3(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxInt3Int3Int3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMaxInt3Int3Int3(inV1, out);
            verifyResultsMaxInt3Int3Int3(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxInt3Int3Int3: " + e.toString());
        }
    }

    private void verifyResultsMaxInt3Int3Int3(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        int[] arrayInV1 = new int[INPUTSIZE * 4];
        inV1.copyTo(arrayInV1);
        int[] arrayInV2 = new int[INPUTSIZE * 4];
        inV2.copyTo(arrayInV2);
        int[] arrayOut = new int[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntInt args = new ArgumentsIntIntInt();
                args.inV1 = arrayInV1[i * 4 + j];
                args.inV2 = arrayInV2[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %d", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %d", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxInt3Int3Int3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxUint3Uint3Uint3() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 3, 0xe30bc76f6d24027fL);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 3, 0xe30bc76f6d24027fL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 3), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMaxUint3Uint3Uint3(inV1, out);
            verifyResultsMaxUint3Uint3Uint3(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUint3Uint3Uint3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMaxUint3Uint3Uint3(inV1, out);
            verifyResultsMaxUint3Uint3Uint3(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUint3Uint3Uint3: " + e.toString());
        }
    }

    private void verifyResultsMaxUint3Uint3Uint3(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        int[] arrayInV1 = new int[INPUTSIZE * 4];
        inV1.copyTo(arrayInV1);
        int[] arrayInV2 = new int[INPUTSIZE * 4];
        inV2.copyTo(arrayInV2);
        int[] arrayOut = new int[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUint args = new ArgumentsUintUintUint();
                args.inV1 = arrayInV1[i * 4 + j];
                args.inV2 = arrayInV2[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %x", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %x", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUint3Uint3Uint3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxChar4Char4Char4() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 4, 0xe04608dcd722648eL);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 4, 0xe04608dcd722648eL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 4), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMaxChar4Char4Char4(inV1, out);
            verifyResultsMaxChar4Char4Char4(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxChar4Char4Char4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMaxChar4Char4Char4(inV1, out);
            verifyResultsMaxChar4Char4Char4(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxChar4Char4Char4: " + e.toString());
        }
    }

    private void verifyResultsMaxChar4Char4Char4(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        byte[] arrayInV1 = new byte[INPUTSIZE * 4];
        inV1.copyTo(arrayInV1);
        byte[] arrayInV2 = new byte[INPUTSIZE * 4];
        inV2.copyTo(arrayInV2);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharChar args = new ArgumentsCharCharChar();
                args.inV1 = arrayInV1[i * 4 + j];
                args.inV2 = arrayInV2[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %d", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %d", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxChar4Char4Char4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxUchar4Uchar4Uchar4() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 4, 0x7be71375bba5c809L);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 4, 0x7be71375bba5c809L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 4), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMaxUchar4Uchar4Uchar4(inV1, out);
            verifyResultsMaxUchar4Uchar4Uchar4(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUchar4Uchar4Uchar4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMaxUchar4Uchar4Uchar4(inV1, out);
            verifyResultsMaxUchar4Uchar4Uchar4(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUchar4Uchar4Uchar4: " + e.toString());
        }
    }

    private void verifyResultsMaxUchar4Uchar4Uchar4(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        byte[] arrayInV1 = new byte[INPUTSIZE * 4];
        inV1.copyTo(arrayInV1);
        byte[] arrayInV2 = new byte[INPUTSIZE * 4];
        inV2.copyTo(arrayInV2);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUchar args = new ArgumentsUcharUcharUchar();
                args.inV1 = arrayInV1[i * 4 + j];
                args.inV2 = arrayInV2[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %x", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %x", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUchar4Uchar4Uchar4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxShort4Short4Short4() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 4, 0xebb390ab5aa8d80cL);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 4, 0xebb390ab5aa8d80cL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 4), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMaxShort4Short4Short4(inV1, out);
            verifyResultsMaxShort4Short4Short4(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxShort4Short4Short4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMaxShort4Short4Short4(inV1, out);
            verifyResultsMaxShort4Short4Short4(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxShort4Short4Short4: " + e.toString());
        }
    }

    private void verifyResultsMaxShort4Short4Short4(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        short[] arrayInV1 = new short[INPUTSIZE * 4];
        inV1.copyTo(arrayInV1);
        short[] arrayInV2 = new short[INPUTSIZE * 4];
        inV2.copyTo(arrayInV2);
        short[] arrayOut = new short[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShort args = new ArgumentsShortShortShort();
                args.inV1 = arrayInV1[i * 4 + j];
                args.inV2 = arrayInV2[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %d", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %d", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxShort4Short4Short4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxUshort4Ushort4Ushort4() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 4, 0xbe1b82d8a6d51dafL);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 4, 0xbe1b82d8a6d51dafL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 4), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMaxUshort4Ushort4Ushort4(inV1, out);
            verifyResultsMaxUshort4Ushort4Ushort4(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUshort4Ushort4Ushort4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMaxUshort4Ushort4Ushort4(inV1, out);
            verifyResultsMaxUshort4Ushort4Ushort4(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUshort4Ushort4Ushort4: " + e.toString());
        }
    }

    private void verifyResultsMaxUshort4Ushort4Ushort4(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        short[] arrayInV1 = new short[INPUTSIZE * 4];
        inV1.copyTo(arrayInV1);
        short[] arrayInV2 = new short[INPUTSIZE * 4];
        inV2.copyTo(arrayInV2);
        short[] arrayOut = new short[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshort args = new ArgumentsUshortUshortUshort();
                args.inV1 = arrayInV1[i * 4 + j];
                args.inV2 = arrayInV2[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %x", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %x", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUshort4Ushort4Ushort4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxInt4Int4Int4() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 4, 0x4c4c61f751487795L);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 4, 0x4c4c61f751487795L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 4), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMaxInt4Int4Int4(inV1, out);
            verifyResultsMaxInt4Int4Int4(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxInt4Int4Int4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMaxInt4Int4Int4(inV1, out);
            verifyResultsMaxInt4Int4Int4(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxInt4Int4Int4: " + e.toString());
        }
    }

    private void verifyResultsMaxInt4Int4Int4(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        int[] arrayInV1 = new int[INPUTSIZE * 4];
        inV1.copyTo(arrayInV1);
        int[] arrayInV2 = new int[INPUTSIZE * 4];
        inV2.copyTo(arrayInV2);
        int[] arrayOut = new int[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntInt args = new ArgumentsIntIntInt();
                args.inV1 = arrayInV1[i * 4 + j];
                args.inV2 = arrayInV2[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %d", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %d", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxInt4Int4Int4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMaxUint4Uint4Uint4() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 4, 0x8c04758cbc3134eL);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 4, 0x8c04758cbc3134eL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 4), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMaxUint4Uint4Uint4(inV1, out);
            verifyResultsMaxUint4Uint4Uint4(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUint4Uint4Uint4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMaxUint4Uint4Uint4(inV1, out);
            verifyResultsMaxUint4Uint4Uint4(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMaxUint4Uint4Uint4: " + e.toString());
        }
    }

    private void verifyResultsMaxUint4Uint4Uint4(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        int[] arrayInV1 = new int[INPUTSIZE * 4];
        inV1.copyTo(arrayInV1);
        int[] arrayInV2 = new int[INPUTSIZE * 4];
        inV2.copyTo(arrayInV2);
        int[] arrayOut = new int[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUint args = new ArgumentsUintUintUint();
                args.inV1 = arrayInV1[i * 4 + j];
                args.inV2 = arrayInV2[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMax(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %x", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %x", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMaxUint4Uint4Uint4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public void testMax() {
        checkMaxFloatFloatFloat();
        checkMaxFloat2Float2Float2();
        checkMaxFloat3Float3Float3();
        checkMaxFloat4Float4Float4();
        checkMaxCharCharChar();
        checkMaxUcharUcharUchar();
        checkMaxShortShortShort();
        checkMaxUshortUshortUshort();
        checkMaxIntIntInt();
        checkMaxUintUintUint();
        checkMaxChar2Char2Char2();
        checkMaxUchar2Uchar2Uchar2();
        checkMaxShort2Short2Short2();
        checkMaxUshort2Ushort2Ushort2();
        checkMaxInt2Int2Int2();
        checkMaxUint2Uint2Uint2();
        checkMaxChar3Char3Char3();
        checkMaxUchar3Uchar3Uchar3();
        checkMaxShort3Short3Short3();
        checkMaxUshort3Ushort3Ushort3();
        checkMaxInt3Int3Int3();
        checkMaxUint3Uint3Uint3();
        checkMaxChar4Char4Char4();
        checkMaxUchar4Uchar4Uchar4();
        checkMaxShort4Short4Short4();
        checkMaxUshort4Ushort4Ushort4();
        checkMaxInt4Int4Int4();
        checkMaxUint4Uint4Uint4();
    }
}
