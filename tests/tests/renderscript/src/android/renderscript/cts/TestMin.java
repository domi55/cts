/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Don't edit this file!  It is auto-generated by frameworks/rs/api/gen_runtime.

package android.renderscript.cts;

import android.renderscript.Allocation;
import android.renderscript.RSRuntimeException;
import android.renderscript.Element;

public class TestMin extends RSBaseCompute {

    private ScriptC_TestMin script;
    private ScriptC_TestMinRelaxed scriptRelaxed;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        script = new ScriptC_TestMin(mRS);
        scriptRelaxed = new ScriptC_TestMinRelaxed(mRS);
    }

    public class ArgumentsFloatFloatFloat {
        public float in;
        public float in1;
        public float out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkMinFloatFloatFloat() {
        Allocation in = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0xbdad0b0971217378L);
        Allocation in1 = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0xbdad0b0971217378L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 1), INPUTSIZE);
            script.set_gAllocIn1(in1);
            script.forEach_testMinFloatFloatFloat(in, out);
            verifyResultsMinFloatFloatFloat(in, in1, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinFloatFloatFloat: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocIn1(in1);
            scriptRelaxed.forEach_testMinFloatFloatFloat(in, out);
            verifyResultsMinFloatFloatFloat(in, in1, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinFloatFloatFloat: " + e.toString());
        }
    }

    private void verifyResultsMinFloatFloatFloat(Allocation in, Allocation in1, Allocation out, boolean relaxed) {
        float[] arrayIn = new float[INPUTSIZE * 1];
        in.copyTo(arrayIn);
        float[] arrayIn1 = new float[INPUTSIZE * 1];
        in1.copyTo(arrayIn1);
        float[] arrayOut = new float[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloat args = new ArgumentsFloatFloatFloat();
                args.in = arrayIn[i];
                args.in1 = arrayIn1[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                neededUlf = (int) (Math.abs(args.out - arrayOut[i * 1 + j]) / Math.ulp(args.out) + 0.5);
                if (neededUlf > ulf) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input in: %x %.16f", Float.floatToRawIntBits(args.in), args.in));
                    message.append("\n");
                    message.append(String.format("Input in1: %x %.16f", Float.floatToRawIntBits(args.in1), args.in1));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x %.16f", Float.floatToRawIntBits(args.out), args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x %.16f", Float.floatToRawIntBits(arrayOut[i * 1 + j]), arrayOut[i * 1 + j]));
                    neededUlf = (int) (Math.abs(args.out - arrayOut[i * 1 + j]) / Math.ulp(args.out) + 0.5);
                    if (neededUlf > ulf) {
                        message.append(String.format(" FAILED, ulf needed %d, specified %d", neededUlf, ulf));
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinFloatFloatFloat" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMinFloat2Float2Float2() {
        Allocation in = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 2, 0x2f1cc4b149b5008eL);
        Allocation in1 = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 2, 0x2f1cc4b149b5008eL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 2), INPUTSIZE);
            script.set_gAllocIn1(in1);
            script.forEach_testMinFloat2Float2Float2(in, out);
            verifyResultsMinFloat2Float2Float2(in, in1, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinFloat2Float2Float2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocIn1(in1);
            scriptRelaxed.forEach_testMinFloat2Float2Float2(in, out);
            verifyResultsMinFloat2Float2Float2(in, in1, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinFloat2Float2Float2: " + e.toString());
        }
    }

    private void verifyResultsMinFloat2Float2Float2(Allocation in, Allocation in1, Allocation out, boolean relaxed) {
        float[] arrayIn = new float[INPUTSIZE * 2];
        in.copyTo(arrayIn);
        float[] arrayIn1 = new float[INPUTSIZE * 2];
        in1.copyTo(arrayIn1);
        float[] arrayOut = new float[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloat args = new ArgumentsFloatFloatFloat();
                args.in = arrayIn[i * 2 + j];
                args.in1 = arrayIn1[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                neededUlf = (int) (Math.abs(args.out - arrayOut[i * 2 + j]) / Math.ulp(args.out) + 0.5);
                if (neededUlf > ulf) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input in: %x %.16f", Float.floatToRawIntBits(args.in), args.in));
                    message.append("\n");
                    message.append(String.format("Input in1: %x %.16f", Float.floatToRawIntBits(args.in1), args.in1));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x %.16f", Float.floatToRawIntBits(args.out), args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x %.16f", Float.floatToRawIntBits(arrayOut[i * 2 + j]), arrayOut[i * 2 + j]));
                    neededUlf = (int) (Math.abs(args.out - arrayOut[i * 2 + j]) / Math.ulp(args.out) + 0.5);
                    if (neededUlf > ulf) {
                        message.append(String.format(" FAILED, ulf needed %d, specified %d", neededUlf, ulf));
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinFloat2Float2Float2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMinFloat3Float3Float3() {
        Allocation in = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 3, 0x8381a2d14b93022fL);
        Allocation in1 = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 3, 0x8381a2d14b93022fL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 3), INPUTSIZE);
            script.set_gAllocIn1(in1);
            script.forEach_testMinFloat3Float3Float3(in, out);
            verifyResultsMinFloat3Float3Float3(in, in1, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinFloat3Float3Float3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocIn1(in1);
            scriptRelaxed.forEach_testMinFloat3Float3Float3(in, out);
            verifyResultsMinFloat3Float3Float3(in, in1, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinFloat3Float3Float3: " + e.toString());
        }
    }

    private void verifyResultsMinFloat3Float3Float3(Allocation in, Allocation in1, Allocation out, boolean relaxed) {
        float[] arrayIn = new float[INPUTSIZE * 4];
        in.copyTo(arrayIn);
        float[] arrayIn1 = new float[INPUTSIZE * 4];
        in1.copyTo(arrayIn1);
        float[] arrayOut = new float[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloat args = new ArgumentsFloatFloatFloat();
                args.in = arrayIn[i * 4 + j];
                args.in1 = arrayIn1[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                neededUlf = (int) (Math.abs(args.out - arrayOut[i * 4 + j]) / Math.ulp(args.out) + 0.5);
                if (neededUlf > ulf) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input in: %x %.16f", Float.floatToRawIntBits(args.in), args.in));
                    message.append("\n");
                    message.append(String.format("Input in1: %x %.16f", Float.floatToRawIntBits(args.in1), args.in1));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x %.16f", Float.floatToRawIntBits(args.out), args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x %.16f", Float.floatToRawIntBits(arrayOut[i * 4 + j]), arrayOut[i * 4 + j]));
                    neededUlf = (int) (Math.abs(args.out - arrayOut[i * 4 + j]) / Math.ulp(args.out) + 0.5);
                    if (neededUlf > ulf) {
                        message.append(String.format(" FAILED, ulf needed %d, specified %d", neededUlf, ulf));
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinFloat3Float3Float3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMinFloat4Float4Float4() {
        Allocation in = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 4, 0xd7e680f14d7103d0L);
        Allocation in1 = CreateRandomAllocation(mRS, Element.DataType.FLOAT_32, 4, 0xd7e680f14d7103d0L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 4), INPUTSIZE);
            script.set_gAllocIn1(in1);
            script.forEach_testMinFloat4Float4Float4(in, out);
            verifyResultsMinFloat4Float4Float4(in, in1, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinFloat4Float4Float4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.FLOAT_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocIn1(in1);
            scriptRelaxed.forEach_testMinFloat4Float4Float4(in, out);
            verifyResultsMinFloat4Float4Float4(in, in1, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinFloat4Float4Float4: " + e.toString());
        }
    }

    private void verifyResultsMinFloat4Float4Float4(Allocation in, Allocation in1, Allocation out, boolean relaxed) {
        float[] arrayIn = new float[INPUTSIZE * 4];
        in.copyTo(arrayIn);
        float[] arrayIn1 = new float[INPUTSIZE * 4];
        in1.copyTo(arrayIn1);
        float[] arrayOut = new float[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloat args = new ArgumentsFloatFloatFloat();
                args.in = arrayIn[i * 4 + j];
                args.in1 = arrayIn1[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                neededUlf = (int) (Math.abs(args.out - arrayOut[i * 4 + j]) / Math.ulp(args.out) + 0.5);
                if (neededUlf > ulf) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input in: %x %.16f", Float.floatToRawIntBits(args.in), args.in));
                    message.append("\n");
                    message.append(String.format("Input in1: %x %.16f", Float.floatToRawIntBits(args.in1), args.in1));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x %.16f", Float.floatToRawIntBits(args.out), args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x %.16f", Float.floatToRawIntBits(arrayOut[i * 4 + j]), arrayOut[i * 4 + j]));
                    neededUlf = (int) (Math.abs(args.out - arrayOut[i * 4 + j]) / Math.ulp(args.out) + 0.5);
                    if (neededUlf > ulf) {
                        message.append(String.format(" FAILED, ulf needed %d, specified %d", neededUlf, ulf));
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinFloat4Float4Float4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsCharCharChar {
        public byte inV1;
        public byte inV2;
        public byte out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkMinCharCharChar() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0x78bd3bd20e81b31aL);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0x78bd3bd20e81b31aL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 1), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMinCharCharChar(inV1, out);
            verifyResultsMinCharCharChar(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinCharCharChar: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMinCharCharChar(inV1, out);
            verifyResultsMinCharCharChar(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinCharCharChar: " + e.toString());
        }
    }

    private void verifyResultsMinCharCharChar(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        byte[] arrayInV1 = new byte[INPUTSIZE * 1];
        inV1.copyTo(arrayInV1);
        byte[] arrayInV2 = new byte[INPUTSIZE * 1];
        inV2.copyTo(arrayInV2);
        byte[] arrayOut = new byte[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharChar args = new ArgumentsCharCharChar();
                args.inV1 = arrayInV1[i];
                args.inV2 = arrayInV2[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %d", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %d", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinCharCharChar" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsUcharUcharUchar {
        public byte inV1;
        public byte inV2;
        public byte out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkMinUcharUcharUchar() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0x1469cbe934456545L);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0x1469cbe934456545L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 1), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMinUcharUcharUchar(inV1, out);
            verifyResultsMinUcharUcharUchar(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinUcharUcharUchar: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMinUcharUcharUchar(inV1, out);
            verifyResultsMinUcharUcharUchar(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinUcharUcharUchar: " + e.toString());
        }
    }

    private void verifyResultsMinUcharUcharUchar(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        byte[] arrayInV1 = new byte[INPUTSIZE * 1];
        inV1.copyTo(arrayInV1);
        byte[] arrayInV2 = new byte[INPUTSIZE * 1];
        inV2.copyTo(arrayInV2);
        byte[] arrayOut = new byte[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUchar args = new ArgumentsUcharUcharUchar();
                args.inV1 = arrayInV1[i];
                args.inV2 = arrayInV2[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %x", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %x", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinUcharUcharUchar" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsShortShortShort {
        public short inV1;
        public short inV2;
        public short out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkMinShortShortShort() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0x265d6881f2c0c1acL);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0x265d6881f2c0c1acL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 1), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMinShortShortShort(inV1, out);
            verifyResultsMinShortShortShort(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinShortShortShort: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMinShortShortShort(inV1, out);
            verifyResultsMinShortShortShort(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinShortShortShort: " + e.toString());
        }
    }

    private void verifyResultsMinShortShortShort(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        short[] arrayInV1 = new short[INPUTSIZE * 1];
        inV1.copyTo(arrayInV1);
        short[] arrayInV2 = new short[INPUTSIZE * 1];
        inV2.copyTo(arrayInV2);
        short[] arrayOut = new short[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShort args = new ArgumentsShortShortShort();
                args.inV1 = arrayInV1[i];
                args.inV2 = arrayInV2[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %d", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %d", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinShortShortShort" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsUshortUshortUshort {
        public short inV1;
        public short inV2;
        public short out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkMinUshortUshortUshort() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0xf8a042afcc4e95ffL);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0xf8a042afcc4e95ffL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 1), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMinUshortUshortUshort(inV1, out);
            verifyResultsMinUshortUshortUshort(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinUshortUshortUshort: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMinUshortUshortUshort(inV1, out);
            verifyResultsMinUshortUshortUshort(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinUshortUshortUshort: " + e.toString());
        }
    }

    private void verifyResultsMinUshortUshortUshort(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        short[] arrayInV1 = new short[INPUTSIZE * 1];
        inV1.copyTo(arrayInV1);
        short[] arrayInV2 = new short[INPUTSIZE * 1];
        inV2.copyTo(arrayInV2);
        short[] arrayOut = new short[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshort args = new ArgumentsUshortUshortUshort();
                args.inV1 = arrayInV1[i];
                args.inV2 = arrayInV2[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %x", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %x", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinUshortUshortUshort" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsIntIntInt {
        public int inV1;
        public int inV2;
        public int out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkMinIntIntInt() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0xfb5d72ade703fc11L);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0xfb5d72ade703fc11L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 1), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMinIntIntInt(inV1, out);
            verifyResultsMinIntIntInt(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinIntIntInt: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMinIntIntInt(inV1, out);
            verifyResultsMinIntIntInt(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinIntIntInt: " + e.toString());
        }
    }

    private void verifyResultsMinIntIntInt(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        int[] arrayInV1 = new int[INPUTSIZE * 1];
        inV1.copyTo(arrayInV1);
        int[] arrayInV2 = new int[INPUTSIZE * 1];
        inV2.copyTo(arrayInV2);
        int[] arrayOut = new int[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntInt args = new ArgumentsIntIntInt();
                args.inV1 = arrayInV1[i];
                args.inV2 = arrayInV2[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %d", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %d", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinIntIntInt" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public class ArgumentsUintUintUint {
        public int inV1;
        public int inV2;
        public int out;

        public int ulf;
        public int ulfRelaxed;
    }

    private void checkMinUintUintUint() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0xe66a5218de3898daL);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0xe66a5218de3898daL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 1), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMinUintUintUint(inV1, out);
            verifyResultsMinUintUintUint(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinUintUintUint: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMinUintUintUint(inV1, out);
            verifyResultsMinUintUintUint(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinUintUintUint: " + e.toString());
        }
    }

    private void verifyResultsMinUintUintUint(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        int[] arrayInV1 = new int[INPUTSIZE * 1];
        inV1.copyTo(arrayInV1);
        int[] arrayInV2 = new int[INPUTSIZE * 1];
        inV2.copyTo(arrayInV2);
        int[] arrayOut = new int[INPUTSIZE * 1];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUint args = new ArgumentsUintUintUint();
                args.inV1 = arrayInV1[i];
                args.inV2 = arrayInV2[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %x", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %x", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 1 + j]));
                    if (args.out != arrayOut[i * 1 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinUintUintUint" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMinChar2Char2Char2() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 2, 0x29373baac8ef771cL);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 2, 0x29373baac8ef771cL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 2), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMinChar2Char2Char2(inV1, out);
            verifyResultsMinChar2Char2Char2(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinChar2Char2Char2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMinChar2Char2Char2(inV1, out);
            verifyResultsMinChar2Char2Char2(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinChar2Char2Char2: " + e.toString());
        }
    }

    private void verifyResultsMinChar2Char2Char2(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        byte[] arrayInV1 = new byte[INPUTSIZE * 2];
        inV1.copyTo(arrayInV1);
        byte[] arrayInV2 = new byte[INPUTSIZE * 2];
        inV2.copyTo(arrayInV2);
        byte[] arrayOut = new byte[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharChar args = new ArgumentsCharCharChar();
                args.inV1 = arrayInV1[i * 2 + j];
                args.inV2 = arrayInV2[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %d", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %d", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinChar2Char2Char2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMinUchar2Uchar2Uchar2() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 2, 0x3c36fd71caf0cf8fL);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 2, 0x3c36fd71caf0cf8fL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 2), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMinUchar2Uchar2Uchar2(inV1, out);
            verifyResultsMinUchar2Uchar2Uchar2(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinUchar2Uchar2Uchar2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMinUchar2Uchar2Uchar2(inV1, out);
            verifyResultsMinUchar2Uchar2Uchar2(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinUchar2Uchar2Uchar2: " + e.toString());
        }
    }

    private void verifyResultsMinUchar2Uchar2Uchar2(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        byte[] arrayInV1 = new byte[INPUTSIZE * 2];
        inV1.copyTo(arrayInV1);
        byte[] arrayInV2 = new byte[INPUTSIZE * 2];
        inV2.copyTo(arrayInV2);
        byte[] arrayOut = new byte[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUchar args = new ArgumentsUcharUcharUchar();
                args.inV1 = arrayInV1[i * 2 + j];
                args.inV2 = arrayInV2[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %x", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %x", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinUchar2Uchar2Uchar2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMinShort2Short2Short2() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 2, 0xac037aa769f3df92L);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 2, 0xac037aa769f3df92L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 2), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMinShort2Short2Short2(inV1, out);
            verifyResultsMinShort2Short2Short2(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinShort2Short2Short2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMinShort2Short2Short2(inV1, out);
            verifyResultsMinShort2Short2Short2(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinShort2Short2Short2: " + e.toString());
        }
    }

    private void verifyResultsMinShort2Short2Short2(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        short[] arrayInV1 = new short[INPUTSIZE * 2];
        inV1.copyTo(arrayInV1);
        short[] arrayInV2 = new short[INPUTSIZE * 2];
        inV2.copyTo(arrayInV2);
        short[] arrayOut = new short[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShort args = new ArgumentsShortShortShort();
                args.inV1 = arrayInV1[i * 2 + j];
                args.inV2 = arrayInV2[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %d", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %d", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinShort2Short2Short2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMinUshort2Ushort2Ushort2() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 2, 0x2743846f878f68ddL);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 2, 0x2743846f878f68ddL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 2), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMinUshort2Ushort2Ushort2(inV1, out);
            verifyResultsMinUshort2Ushort2Ushort2(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinUshort2Ushort2Ushort2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMinUshort2Ushort2Ushort2(inV1, out);
            verifyResultsMinUshort2Ushort2Ushort2(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinUshort2Ushort2Ushort2: " + e.toString());
        }
    }

    private void verifyResultsMinUshort2Ushort2Ushort2(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        short[] arrayInV1 = new short[INPUTSIZE * 2];
        inV1.copyTo(arrayInV1);
        short[] arrayInV2 = new short[INPUTSIZE * 2];
        inV2.copyTo(arrayInV2);
        short[] arrayOut = new short[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshort args = new ArgumentsUshortUshortUshort();
                args.inV1 = arrayInV1[i * 2 + j];
                args.inV2 = arrayInV2[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %x", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %x", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinUshort2Ushort2Ushort2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMinInt2Int2Int2() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 2, 0x4bc6c69713df277bL);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 2, 0x4bc6c69713df277bL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 2), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMinInt2Int2Int2(inV1, out);
            verifyResultsMinInt2Int2Int2(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinInt2Int2Int2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMinInt2Int2Int2(inV1, out);
            verifyResultsMinInt2Int2Int2(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinInt2Int2Int2: " + e.toString());
        }
    }

    private void verifyResultsMinInt2Int2Int2(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        int[] arrayInV1 = new int[INPUTSIZE * 2];
        inV1.copyTo(arrayInV1);
        int[] arrayInV2 = new int[INPUTSIZE * 2];
        inV2.copyTo(arrayInV2);
        int[] arrayOut = new int[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntInt args = new ArgumentsIntIntInt();
                args.inV1 = arrayInV1[i * 2 + j];
                args.inV2 = arrayInV2[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %d", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %d", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinInt2Int2Int2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMinUint2Uint2Uint2() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 2, 0x51b17a26bd9025dcL);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 2, 0x51b17a26bd9025dcL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 2), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMinUint2Uint2Uint2(inV1, out);
            verifyResultsMinUint2Uint2Uint2(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinUint2Uint2Uint2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMinUint2Uint2Uint2(inV1, out);
            verifyResultsMinUint2Uint2Uint2(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinUint2Uint2Uint2: " + e.toString());
        }
    }

    private void verifyResultsMinUint2Uint2Uint2(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        int[] arrayInV1 = new int[INPUTSIZE * 2];
        inV1.copyTo(arrayInV1);
        int[] arrayInV2 = new int[INPUTSIZE * 2];
        inV2.copyTo(arrayInV2);
        int[] arrayOut = new int[INPUTSIZE * 2];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUint args = new ArgumentsUintUintUint();
                args.inV1 = arrayInV1[i * 2 + j];
                args.inV2 = arrayInV2[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %x", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %x", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 2 + j]));
                    if (args.out != arrayOut[i * 2 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinUint2Uint2Uint2" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMinChar3Char3Char3() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 3, 0x4eebbb94278e87ebL);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 3, 0x4eebbb94278e87ebL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 3), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMinChar3Char3Char3(inV1, out);
            verifyResultsMinChar3Char3Char3(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinChar3Char3Char3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMinChar3Char3Char3(inV1, out);
            verifyResultsMinChar3Char3Char3(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinChar3Char3Char3: " + e.toString());
        }
    }

    private void verifyResultsMinChar3Char3Char3(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        byte[] arrayInV1 = new byte[INPUTSIZE * 4];
        inV1.copyTo(arrayInV1);
        byte[] arrayInV2 = new byte[INPUTSIZE * 4];
        inV2.copyTo(arrayInV2);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharChar args = new ArgumentsCharCharChar();
                args.inV1 = arrayInV1[i * 4 + j];
                args.inV2 = arrayInV2[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %d", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %d", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinChar3Char3Char3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMinUchar3Uchar3Uchar3() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 3, 0x909bdb91ccced130L);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 3, 0x909bdb91ccced130L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 3), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMinUchar3Uchar3Uchar3(inV1, out);
            verifyResultsMinUchar3Uchar3Uchar3(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinUchar3Uchar3Uchar3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMinUchar3Uchar3Uchar3(inV1, out);
            verifyResultsMinUchar3Uchar3Uchar3(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinUchar3Uchar3Uchar3: " + e.toString());
        }
    }

    private void verifyResultsMinUchar3Uchar3Uchar3(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        byte[] arrayInV1 = new byte[INPUTSIZE * 4];
        inV1.copyTo(arrayInV1);
        byte[] arrayInV2 = new byte[INPUTSIZE * 4];
        inV2.copyTo(arrayInV2);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUchar args = new ArgumentsUcharUcharUchar();
                args.inV1 = arrayInV1[i * 4 + j];
                args.inV2 = arrayInV2[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %x", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %x", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinUchar3Uchar3Uchar3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMinShort3Short3Short3() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 3, 0x6858c76bd1e133L);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 3, 0x6858c76bd1e133L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 3), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMinShort3Short3Short3(inV1, out);
            verifyResultsMinShort3Short3Short3(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinShort3Short3Short3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMinShort3Short3Short3(inV1, out);
            verifyResultsMinShort3Short3Short3(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinShort3Short3Short3: " + e.toString());
        }
    }

    private void verifyResultsMinShort3Short3Short3(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        short[] arrayInV1 = new short[INPUTSIZE * 4];
        inV1.copyTo(arrayInV1);
        short[] arrayInV2 = new short[INPUTSIZE * 4];
        inV2.copyTo(arrayInV2);
        short[] arrayOut = new short[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShort args = new ArgumentsShortShortShort();
                args.inV1 = arrayInV1[i * 4 + j];
                args.inV2 = arrayInV2[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %d", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %d", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinShort3Short3Short3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMinUshort3Ushort3Ushort3() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 3, 0xa7331d68d0745a74L);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 3, 0xa7331d68d0745a74L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 3), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMinUshort3Ushort3Ushort3(inV1, out);
            verifyResultsMinUshort3Ushort3Ushort3(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinUshort3Ushort3Ushort3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMinUshort3Ushort3Ushort3(inV1, out);
            verifyResultsMinUshort3Ushort3Ushort3(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinUshort3Ushort3Ushort3: " + e.toString());
        }
    }

    private void verifyResultsMinUshort3Ushort3Ushort3(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        short[] arrayInV1 = new short[INPUTSIZE * 4];
        inV1.copyTo(arrayInV1);
        short[] arrayInV2 = new short[INPUTSIZE * 4];
        inV2.copyTo(arrayInV2);
        short[] arrayOut = new short[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshort args = new ArgumentsUshortUshortUshort();
                args.inV1 = arrayInV1[i * 4 + j];
                args.inV2 = arrayInV2[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %x", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %x", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinUshort3Ushort3Ushort3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMinInt3Int3Int3() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 3, 0x58ac4a91deb46f64L);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 3, 0x58ac4a91deb46f64L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 3), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMinInt3Int3Int3(inV1, out);
            verifyResultsMinInt3Int3Int3(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinInt3Int3Int3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMinInt3Int3Int3(inV1, out);
            verifyResultsMinInt3Int3Int3(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinInt3Int3Int3: " + e.toString());
        }
    }

    private void verifyResultsMinInt3Int3Int3(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        int[] arrayInV1 = new int[INPUTSIZE * 4];
        inV1.copyTo(arrayInV1);
        int[] arrayInV2 = new int[INPUTSIZE * 4];
        inV2.copyTo(arrayInV2);
        int[] arrayOut = new int[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntInt args = new ArgumentsIntIntInt();
                args.inV1 = arrayInV1[i * 4 + j];
                args.inV2 = arrayInV2[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %d", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %d", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinInt3Int3Int3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMinUint3Uint3Uint3() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 3, 0x7765fa101c2f36abL);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 3, 0x7765fa101c2f36abL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 3), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMinUint3Uint3Uint3(inV1, out);
            verifyResultsMinUint3Uint3Uint3(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinUint3Uint3Uint3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMinUint3Uint3Uint3(inV1, out);
            verifyResultsMinUint3Uint3Uint3(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinUint3Uint3Uint3: " + e.toString());
        }
    }

    private void verifyResultsMinUint3Uint3Uint3(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        int[] arrayInV1 = new int[INPUTSIZE * 4];
        inV1.copyTo(arrayInV1);
        int[] arrayInV2 = new int[INPUTSIZE * 4];
        inV2.copyTo(arrayInV2);
        int[] arrayOut = new int[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUint args = new ArgumentsUintUintUint();
                args.inV1 = arrayInV1[i * 4 + j];
                args.inV2 = arrayInV2[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %x", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %x", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinUint3Uint3Uint3" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMinChar4Char4Char4() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 4, 0x74a03b7d862d98baL);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_8, 4, 0x74a03b7d862d98baL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 4), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMinChar4Char4Char4(inV1, out);
            verifyResultsMinChar4Char4Char4(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinChar4Char4Char4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_8, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMinChar4Char4Char4(inV1, out);
            verifyResultsMinChar4Char4Char4(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinChar4Char4Char4: " + e.toString());
        }
    }

    private void verifyResultsMinChar4Char4Char4(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        byte[] arrayInV1 = new byte[INPUTSIZE * 4];
        inV1.copyTo(arrayInV1);
        byte[] arrayInV2 = new byte[INPUTSIZE * 4];
        inV2.copyTo(arrayInV2);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharChar args = new ArgumentsCharCharChar();
                args.inV1 = arrayInV1[i * 4 + j];
                args.inV2 = arrayInV2[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %d", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %d", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinChar4Char4Char4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMinUchar4Uchar4Uchar4() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 4, 0xe500b9b1ceacd2d1L);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 4, 0xe500b9b1ceacd2d1L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 4), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMinUchar4Uchar4Uchar4(inV1, out);
            verifyResultsMinUchar4Uchar4Uchar4(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinUchar4Uchar4Uchar4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_8, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMinUchar4Uchar4Uchar4(inV1, out);
            verifyResultsMinUchar4Uchar4Uchar4(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinUchar4Uchar4Uchar4: " + e.toString());
        }
    }

    private void verifyResultsMinUchar4Uchar4Uchar4(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        byte[] arrayInV1 = new byte[INPUTSIZE * 4];
        inV1.copyTo(arrayInV1);
        byte[] arrayInV2 = new byte[INPUTSIZE * 4];
        inV2.copyTo(arrayInV2);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUchar args = new ArgumentsUcharUcharUchar();
                args.inV1 = arrayInV1[i * 4 + j];
                args.inV2 = arrayInV2[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %x", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %x", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinUchar4Uchar4Uchar4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMinShort4Short4Short4() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 4, 0x54cd36e76dafe2d4L);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_16, 4, 0x54cd36e76dafe2d4L);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 4), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMinShort4Short4Short4(inV1, out);
            verifyResultsMinShort4Short4Short4(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinShort4Short4Short4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_16, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMinShort4Short4Short4(inV1, out);
            verifyResultsMinShort4Short4Short4(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinShort4Short4Short4: " + e.toString());
        }
    }

    private void verifyResultsMinShort4Short4Short4(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        short[] arrayInV1 = new short[INPUTSIZE * 4];
        inV1.copyTo(arrayInV1);
        short[] arrayInV2 = new short[INPUTSIZE * 4];
        inV2.copyTo(arrayInV2);
        short[] arrayOut = new short[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShort args = new ArgumentsShortShortShort();
                args.inV1 = arrayInV1[i * 4 + j];
                args.inV2 = arrayInV2[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %d", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %d", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinShort4Short4Short4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMinUshort4Ushort4Ushort4() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 4, 0x2722b66219594c0bL);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 4, 0x2722b66219594c0bL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 4), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMinUshort4Ushort4Ushort4(inV1, out);
            verifyResultsMinUshort4Ushort4Ushort4(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinUshort4Ushort4Ushort4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_16, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMinUshort4Ushort4Ushort4(inV1, out);
            verifyResultsMinUshort4Ushort4Ushort4(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinUshort4Ushort4Ushort4: " + e.toString());
        }
    }

    private void verifyResultsMinUshort4Ushort4Ushort4(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        short[] arrayInV1 = new short[INPUTSIZE * 4];
        inV1.copyTo(arrayInV1);
        short[] arrayInV2 = new short[INPUTSIZE * 4];
        inV2.copyTo(arrayInV2);
        short[] arrayOut = new short[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshort args = new ArgumentsUshortUshortUshort();
                args.inV1 = arrayInV1[i * 4 + j];
                args.inV2 = arrayInV2[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %x", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %x", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinUshort4Ushort4Ushort4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMinInt4Int4Int4() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 4, 0x6591ce8ca989b74dL);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.SIGNED_32, 4, 0x6591ce8ca989b74dL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 4), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMinInt4Int4Int4(inV1, out);
            verifyResultsMinInt4Int4Int4(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinInt4Int4Int4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.SIGNED_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMinInt4Int4Int4(inV1, out);
            verifyResultsMinInt4Int4Int4(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinInt4Int4Int4: " + e.toString());
        }
    }

    private void verifyResultsMinInt4Int4Int4(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        int[] arrayInV1 = new int[INPUTSIZE * 4];
        inV1.copyTo(arrayInV1);
        int[] arrayInV2 = new int[INPUTSIZE * 4];
        inV2.copyTo(arrayInV2);
        int[] arrayOut = new int[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntInt args = new ArgumentsIntIntInt();
                args.inV1 = arrayInV1[i * 4 + j];
                args.inV2 = arrayInV2[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %d", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %d", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %d", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %d", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinInt4Int4Int4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    private void checkMinUint4Uint4Uint4() {
        Allocation inV1 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 4, 0x9d1a79f97ace477aL);
        Allocation inV2 = CreateRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 4, 0x9d1a79f97ace477aL);
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 4), INPUTSIZE);
            script.set_gAllocInV2(inV2);
            script.forEach_testMinUint4Uint4Uint4(inV1, out);
            verifyResultsMinUint4Uint4Uint4(inV1, inV2, out, false);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinUint4Uint4Uint4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, GetElement(mRS, Element.DataType.UNSIGNED_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInV2(inV2);
            scriptRelaxed.forEach_testMinUint4Uint4Uint4(inV1, out);
            verifyResultsMinUint4Uint4Uint4(inV1, inV2, out, true);
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testMinUint4Uint4Uint4: " + e.toString());
        }
    }

    private void verifyResultsMinUint4Uint4Uint4(Allocation inV1, Allocation inV2, Allocation out, boolean relaxed) {
        int[] arrayInV1 = new int[INPUTSIZE * 4];
        inV1.copyTo(arrayInV1);
        int[] arrayInV2 = new int[INPUTSIZE * 4];
        inV2.copyTo(arrayInV2);
        int[] arrayOut = new int[INPUTSIZE * 4];
        out.copyTo(arrayOut);
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUint args = new ArgumentsUintUintUint();
                args.inV1 = arrayInV1[i * 4 + j];
                args.inV2 = arrayInV2[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeMin(args);
                int ulf = relaxed ? args.ulfRelaxed : args.ulf;
                // Figure out what the outputs should have been.
                boolean valid = true;
                int neededUlf = 0;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    StringBuilder message = new StringBuilder();
                    message.append(String.format("Input inV1: %x", args.inV1));
                    message.append("\n");
                    message.append(String.format("Input inV2: %x", args.inV2));
                    message.append("\n");
                    message.append(String.format("Expected output out: %x", args.out));
                    message.append("\n");
                    message.append(String.format("Actual   output out: %x", arrayOut[i * 4 + j]));
                    if (args.out != arrayOut[i * 4 + j]) {
                        message.append(" FAIL");
                    }
                    message.append("\n");
                    assertTrue("Incorrect output for checkMinUint4Uint4Uint4" + (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), valid);
                }
            }
        }
    }

    public void testMin() {
        checkMinFloatFloatFloat();
        checkMinFloat2Float2Float2();
        checkMinFloat3Float3Float3();
        checkMinFloat4Float4Float4();
        checkMinCharCharChar();
        checkMinUcharUcharUchar();
        checkMinShortShortShort();
        checkMinUshortUshortUshort();
        checkMinIntIntInt();
        checkMinUintUintUint();
        checkMinChar2Char2Char2();
        checkMinUchar2Uchar2Uchar2();
        checkMinShort2Short2Short2();
        checkMinUshort2Ushort2Ushort2();
        checkMinInt2Int2Int2();
        checkMinUint2Uint2Uint2();
        checkMinChar3Char3Char3();
        checkMinUchar3Uchar3Uchar3();
        checkMinShort3Short3Short3();
        checkMinUshort3Ushort3Ushort3();
        checkMinInt3Int3Int3();
        checkMinUint3Uint3Uint3();
        checkMinChar4Char4Char4();
        checkMinUchar4Uchar4Uchar4();
        checkMinShort4Short4Short4();
        checkMinUshort4Ushort4Ushort4();
        checkMinInt4Int4Int4();
        checkMinUint4Uint4Uint4();
    }
}
